{"pageProps":{"post":{"readingTime":"3 min read","live":true,"title":"Setters vs ngOnChanges: which one is better?","date":"2020-07-30T00:00:00.322Z","slug":"setters-vs-ng-on-changes","coverImage":"/assets/images/posts/setters-vs-on-changes.webp","collection":"angular","excerpt":"Listening to Input changes can be done in different ways. But which one should you use?","content":"\nGetting notified about an Angular component's property changes is normally done in 2 ways:\n\n- adding a setter to the property\n- using the `ngOnChanges` lifecycle hook\n\nBut... is there a best practice?\n\nThis discussion recently came up with my colleagues while trying to establish a standard practice in our codebase. We tried to find objective arguments to understand which one is better.\n\nAs usual, the answer depends on the scenario.\n\n## Style\n\nStyle is very much a subjective factor, but using a setter is hands-down my favorite approach. Let's take a look at a common scenario:\n\n```typescript\nclass MyComponent {\n  private subject$ = new Subject<string>();\n\n  @Input()\n  set name(name: string) {\n    this.subject$.next(name);\n  }\n}\n```\n\nIt's succinct, type-safe, and encourages the usage of Observables. Not much to dislike, imho.\n\nBut can you **not** add a getter?\n\nYes. It turns out, Angular does not check the previous value by invoking the getter on the property, but stores its value in its component's logical view.\n\nIf you're interested in reading the source code where this happens, [check this out](https://github.com/angular/angular/blob/d1ea1f4c7f3358b730b0d94e65b00bc28cae279c/packages/core/src/render3/bindings.ts#L50).\n\n```typescript\nclass MyComponent implements OnChanges {\n  @Input() name: string;\n\n  private subject$ = new Subject<string>();\n\n  ngOnChanges(changes: SimpleChanges) {\n    // changes.name.currentValue is typed as `any`\n    this.subject$.next(changes.name.currentValue);\n  }\n}\n```\n\nThe `ngOnChanges` lifecycle hook, on the contrary, it's not as nice (in my opinion) - and most importantly, is weakly typed.\n\nAlso - it's worth to mention that using setters usually takes less code, which is always a good thing.\n\n## Performance\n\nDoes performance change much? At first, we thought that `ngOnChanges` would be more efficient as being part of Angular's lifecycle hooks, and therefore being aware of when a property changed.\n\nIt turns out, though, that Angular **does only change a property when the binding is a new instance**. Of course, we're taking into account the change detection being `OnPush`.\n\nPerformance-wise, according to my tests, there isn't a better way, and shouldn't be a factor when deciding which way to go with.\n\n## Dealing with multiple Inputs\n\nThe situation changes when taking into account changes on multiple inputs:\n\n```typescript\nclass MyComponent implements OnChanges {\n  @Input() name: string;\n  @Input() email: string;\n\n  private username$ = new Subject<string>();\n\n  ngOnChanges({ name, email }: SimpleChanges) {\n    const username = name.currentValue || email.currentValue;\n    this.username$.next(username);\n  }\n}\n```\n\nIn this case, it's fairly straightforward and simpler to receive all the inputs at once.\n\nBut because this situation is pretty uncommon, and sometimes a sign of a _code-smell_, you'll find yourselves wanting to use the setter the majority of the time.\n\nAt the end of the day, remember that this decision is always up to you and your team's preferences.\n\n_Thank you for reading, I hope you enjoyed this article. If you did, consider follow me on [Twitter](https://twitter.com/gc_psk) or sign up to the Newsletter using the form below!_\n"},"content":{"compiledSource":"var i=Object.defineProperty,l=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var p=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable;var m=(e,n,s)=>n in e?i(e,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[n]=s,a=(e,n)=>{for(var s in n||(n={}))o.call(n,s)&&m(e,s,n[s]);if(p)for(var s of p(n))c.call(n,s)&&m(e,s,n[s]);return e},r=(e,n)=>l(e,u(n));var N=(e,n)=>{var s={};for(var t in e)o.call(e,t)&&n.indexOf(t)<0&&(s[t]=e[t]);if(e!=null&&p)for(var t of p(e))n.indexOf(t)<0&&c.call(e,t)&&(s[t]=e[t]);return s};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(s){var t=s,{components:e}=t,n=N(t,[\"components\"]);return mdx(MDXLayout,r(a(a({},layoutProps),n),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Getting notified about an Angular component's property changes is normally done in 2 ways:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"adding a setter to the property\"),mdx(\"li\",{parentName:\"ul\"},\"using the \",mdx(\"inlineCode\",{parentName:\"li\"},\"ngOnChanges\"),\" lifecycle hook\")),mdx(\"p\",null,\"But... is there a best practice?\"),mdx(\"p\",null,\"This discussion recently came up with my colleagues while trying to establish a standard practice in our codebase. We tried to find objective arguments to understand which one is better.\"),mdx(\"p\",null,\"As usual, the answer depends on the scenario.\"),mdx(\"h2\",null,\"Style\"),mdx(\"p\",null,\"Style is very much a subjective factor, but using a setter is hands-down my favorite approach. Let's take a look at a common scenario:\"),mdx(\"div\",a({},{className:\"remark-highlight\"}),mdx(\"pre\",a({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",a({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"class\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token class-name\"}),\"MyComponent\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"private\"),\" subject$ \",mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"new\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token class-name\"}),\"Subject\",mdx(\"span\",a({parentName:\"span\"},{className:\"token operator\"}),\"<\"),mdx(\"span\",a({parentName:\"span\"},{className:\"token builtin\"}),\"string\"),mdx(\"span\",a({parentName:\"span\"},{className:\"token operator\"}),\">\")),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token decorator\"}),mdx(\"span\",a({parentName:\"span\"},{className:\"token at operator\"}),\"@\"),mdx(\"span\",a({parentName:\"span\"},{className:\"token function\"}),\"Input\")),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"set\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token function\"}),\"name\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"name\",mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token builtin\"}),\"string\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n    `,mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"this\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"subject$\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token function\"}),\"next\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"name\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`,mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`))),mdx(\"p\",null,\"It's succinct, type-safe, and encourages the usage of Observables. Not much to dislike, imho.\"),mdx(\"p\",null,\"But can you \",mdx(\"strong\",{parentName:\"p\"},\"not\"),\" add a getter?\"),mdx(\"p\",null,\"Yes. It turns out, Angular does not check the previous value by invoking the getter on the property, but stores its value in its component's logical view.\"),mdx(\"p\",null,\"If you're interested in reading the source code where this happens, \",mdx(\"a\",a({parentName:\"p\"},{href:\"https://github.com/angular/angular/blob/d1ea1f4c7f3358b730b0d94e65b00bc28cae279c/packages/core/src/render3/bindings.ts#L50\"}),\"check this out\"),\".\"),mdx(\"div\",a({},{className:\"remark-highlight\"}),mdx(\"pre\",a({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",a({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"class\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token class-name\"}),\"MyComponent\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"implements\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token class-name\"}),\"OnChanges\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token decorator\"}),mdx(\"span\",a({parentName:\"span\"},{className:\"token at operator\"}),\"@\"),mdx(\"span\",a({parentName:\"span\"},{className:\"token function\"}),\"Input\")),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" name\",mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token builtin\"}),\"string\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"private\"),\" subject$ \",mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"new\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token class-name\"}),\"Subject\",mdx(\"span\",a({parentName:\"span\"},{className:\"token operator\"}),\"<\"),mdx(\"span\",a({parentName:\"span\"},{className:\"token builtin\"}),\"string\"),mdx(\"span\",a({parentName:\"span\"},{className:\"token operator\"}),\">\")),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token function\"}),\"ngOnChanges\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"changes\",mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" SimpleChanges\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n    `,mdx(\"span\",a({parentName:\"code\"},{className:\"token comment\"}),\"// changes.name.currentValue is typed as `any`\"),`\n    `,mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"this\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"subject$\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token function\"}),\"next\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"changes\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"name\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"currentValue\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`,mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`))),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"ngOnChanges\"),\" lifecycle hook, on the contrary, it's not as nice (in my opinion) - and most importantly, is weakly typed.\"),mdx(\"p\",null,\"Also - it's worth to mention that using setters usually takes less code, which is always a good thing.\"),mdx(\"h2\",null,\"Performance\"),mdx(\"p\",null,\"Does performance change much? At first, we thought that \",mdx(\"inlineCode\",{parentName:\"p\"},\"ngOnChanges\"),\" would be more efficient as being part of Angular's lifecycle hooks, and therefore being aware of when a property changed.\"),mdx(\"p\",null,\"It turns out, though, that Angular \",mdx(\"strong\",{parentName:\"p\"},\"does only change a property when the binding is a new instance\"),\". Of course, we're taking into account the change detection being \",mdx(\"inlineCode\",{parentName:\"p\"},\"OnPush\"),\".\"),mdx(\"p\",null,\"Performance-wise, according to my tests, there isn't a better way, and shouldn't be a factor when deciding which way to go with.\"),mdx(\"h2\",null,\"Dealing with multiple Inputs\"),mdx(\"p\",null,\"The situation changes when taking into account changes on multiple inputs:\"),mdx(\"div\",a({},{className:\"remark-highlight\"}),mdx(\"pre\",a({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",a({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"class\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token class-name\"}),\"MyComponent\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"implements\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token class-name\"}),\"OnChanges\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token decorator\"}),mdx(\"span\",a({parentName:\"span\"},{className:\"token at operator\"}),\"@\"),mdx(\"span\",a({parentName:\"span\"},{className:\"token function\"}),\"Input\")),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" name\",mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token builtin\"}),\"string\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token decorator\"}),mdx(\"span\",a({parentName:\"span\"},{className:\"token at operator\"}),\"@\"),mdx(\"span\",a({parentName:\"span\"},{className:\"token function\"}),\"Input\")),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" email\",mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token builtin\"}),\"string\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"private\"),\" username$ \",mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"new\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token class-name\"}),\"Subject\",mdx(\"span\",a({parentName:\"span\"},{className:\"token operator\"}),\"<\"),mdx(\"span\",a({parentName:\"span\"},{className:\"token builtin\"}),\"string\"),mdx(\"span\",a({parentName:\"span\"},{className:\"token operator\"}),\">\")),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token function\"}),\"ngOnChanges\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),\" name\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" email \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" SimpleChanges\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n    `,mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" username \",mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" name\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"currentValue \",mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\"||\"),\" email\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"currentValue\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n    `,mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"this\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"username$\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token function\"}),\"next\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"username\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n  `,mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`,mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`))),mdx(\"p\",null,\"In this case, it's fairly straightforward and simpler to receive all the inputs at once.\"),mdx(\"p\",null,\"But because this situation is pretty uncommon, and sometimes a sign of a \",mdx(\"em\",{parentName:\"p\"},\"code-smell\"),\", you'll find yourselves wanting to use the setter the majority of the time.\"),mdx(\"p\",null,\"At the end of the day, remember that this decision is always up to you and your team's preferences.\"),mdx(\"p\",null,mdx(\"em\",{parentName:\"p\"},\"Thank you for reading, I hope you enjoyed this article. If you did, consider follow me on \",mdx(\"a\",a({parentName:\"em\"},{href:\"https://twitter.com/gc_psk\"}),\"Twitter\"),\" or sign up to the Newsletter using the form below!\")))}MDXContent.isMDXComponent=!0;\n","scope":{}},"series":[],"morePosts":[],"moreArticles":[{"readingTime":"2 min read","live":true,"title":"Benchmarking Angular 12 with Webpack 5","date":"2021-05-14T00:00:00.322Z","slug":"webpack-5-angular12","coverImage":"/assets/images/posts/benchmarking-webpack-5.webp","collection":"angular","excerpt":"Angular 12 has been released and with it the much awaited Webpack 5 upgrade. In this post I benchmarked the bundle-size and compilation speed against the previous version"},{"readingTime":"5 min read","live":true,"title":"Principles for creating libraries with Nx and Angular","date":"2021-02-07T00:00:00.322Z","slug":"how-to-organize-nx-modules-with-angular","coverImage":"/assets/images/posts/organize-nx-modules-ngrx.webp","collection":"angular","excerpt":"Working with Nx may be confusing. This article explains how I create Nx libraries and the principles behind my motivations"},{"readingTime":"3 min read","live":true,"title":"Where to put your Angular models?","date":"2020-08-03T00:00:00.322Z","slug":"angular-where-to-put-models","ogImage":{"url":"/assets/images/posts/where-put-angular-models.png"},"coverImage":"/assets/images/posts/where-put-angular-models.webp","collection":"angular","excerpt":"Organizing entities and models in your Angular app may be hard. This article explains where to put your entities and what mistakes to watch out for"},{"readingTime":"5 min read","live":true,"title":"Using the Intersection Observer API with Angular","date":"2020-08-01T00:00:00.322Z","slug":"intersection-observer-with-angular","coverImage":"/assets/images/posts/intersection-observer.webp","collection":"angular","excerpt":"This article shows how to build a directive with Angular that uses the Intersection Observer API to check when an element becomes visible on the page"},{"readingTime":"3 min read","live":true,"title":"Async Rendering with a single Rx Operator","date":"2020-07-11T00:00:00.322Z","slug":"async-rendering-with-a-single-rx-operator","coverImage":"/assets/images/posts/async-rendering.webp","collection":"angular","excerpt":"Increase your app rendering performance with this simple Rx operator"},{"readingTime":"9 min read","live":true,"title":"Building Scalable Multi-Platform Projects with Angular and Nx","date":"2019-08-25T00:00:00.322Z","slug":"building-scalable-multi-platform-projects-with-angular-and-nx","coverImage":"/assets/images/posts/scalable-multiplatform-monorepo.jpeg","collection":"angular","excerpt":"Building a scalable multi-platform monorepo application with Angular and Nx"}],"type":1},"__N_SSG":true}