{"pageProps":{"post":{"readingTime":"5 min read","live":true,"title":"Principles for creating libraries with Nx and Angular","date":"2021-02-07T00:00:00.322Z","slug":"how-to-organize-nx-modules-with-angular","content":"<p>If you've worked with both Nx at least once, you probably know it's quite complex to figure out the best way to organize your code into modules a scalable way, and that makes sense.</p>\n<p>When you're adding some additional code, have you ever thought about where to add it?</p>\n<ul>\n<li>An app?</li>\n<li>A new module within an app?</li>\n<li>The library where it's used?</li>\n<li>Maybe a separate library?</li>\n</ul>\n<p>Yeah - I've been there too.</p>\n<p>After lots of trial and error, I've settled on a way that seems clean, and that plays nicely\nwith the Nx philosophy - but that can only work by following other principles.</p>\n<p>This is still very much a work in progress and may change in the future, but in this article, I want to lay down some principles I follow (and intend to test further) when creating Nx libraries. I will try to dig deeper into each of these and describe them with clearer and more specific details.</p>\n<h2>Why do we use Nx to separate code into libraries?</h2>\n<p>This is the first point to consider: why are we using Nx to split our code into different libraries in the first place?</p>\n<p>There are multiple reasons, but here are some that come to mind:</p>\n<ul>\n<li>I want to be able to reuse code across applications</li>\n<li>I want each library to be a unit of the platform which is developed, changed and tested individually</li>\n<li>I want to restrict the code my applications are allowed to know or use</li>\n</ul>\n<p>Nx also provides smart and efficient caching, which means we do not need to rebuild or re-test stuff that hasn't changed, but this is not of interest given this article's scope.</p>\n<h3>Principle 1: Splitting by Responsibility</h3>\n<p>I usually follow the Module type approach - but I apply it at the library-level. With the fact the Angular modules <em>may</em> go one day, I feel this is also the most future-proof way to think about it.</p>\n<p>For example, I don't recommend writing your State Management and any UI components code within the same library. A State Management library is a Services Module and should not contain any declarations.</p>\n<p>Indeed, the scope of the State Management library is to manipulate and handle the state of a particular slice of the store. By separating the two, we can build and test them independently and swap the implementations if necessary.</p>\n<p>You will also want to access state from different parts of the application (or from multiple applications), and you don't want to bring needless declarations with you along the way.</p>\n<p>Let's assume your company is an enterprise that makes software for writing Tasks (yet another!). What could your libraries look like?</p>\n<div class=\"remark-highlight\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// state management</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> TasksStateModule<span class=\"token punctuation\">,</span> TasksStateService <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@enterprise/tasks/state'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// DTOs - these are very likely shared with your API!</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> CreateTaskDto<span class=\"token punctuation\">,</span> DeleteTaskDto<span class=\"token punctuation\">,</span> UpdateTaskDto <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@enterprise/tasks/dto'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Domain</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Task <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@enterprise/tasks/domain'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// API</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> TasksApiModule <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@enterprise/tasks/api'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// common UI components and containers</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> TasksUiModule <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@enterprise/tasks/ui'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Tasks Page / Routed Component</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> TasksPageModule <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@enterprise/tasks/page'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// routing (rarely needed, only use for overly complex configurations)</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> TasksPageRoutingModule <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@enterprise/tasks/routing'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// specific features of the domain, mostly UI components, services tha facilitate their work</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> CreateTaskFeatureModule <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@enterprise/tasks/features/create-task'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> DeleteTaskFeatureModule <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@enterprise/tasks/features/delete-task'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> NewTaskFormFeatureModule <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@enterprise/tasks/features/new-task-form'</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>The above should give you a good idea of this approach to a decently sized enterprise application.</p>\n<p>You may want to initialize and handle state related to \"tasks\" even outside the \"Tasks page\". This is why it's useful to separate the business domain from the UI components.</p>\n<p>If you're wondering how to create sub-libraries, you can use the \"directory\" parameter when creating a library:</p>\n<div class=\"remark-highlight\"><pre class=\"language-unknown\"><code class=\"language-unknown\">nx generate library ui --directory tasks</code></pre></div>\n<h3>Principle 2: libraries should limit the number of exported entities</h3>\n<p>For example, in the case of a state library, only export state-related entities. That is <em>mostly actions and selectors</em>, or a Facade service that hides actions and events from the consumer if you're using one.</p>\n<p>If you're finding yourself exporting any other entity, such as a client service, an interface (that is not the state), they can likely be placed in another common library, because chances are, these may be used elsewhere.</p>\n<p>This suggests your library <em>may</em> be containing more than it should.</p>\n<div class=\"remark-highlight\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// index.ts</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> TasksStateModule <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./tasks-state.module'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// consumers can interact and retrieve the state using the Facade</span>\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> TasksFacadeService <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./services/tasks-facade.service'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> MockTasksFacadeService <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./services/mock-tasks-facade.service'</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<h3>Principle 3: Libraries should change for one reason and one only</h3>\n<p>We can apply the Single Responsibility Principle to Nx libraries: if a library changes for multiple reasons, then it could (should?) be split.</p>\n<p>This is nothing new, and it's well-described in <em>Clean Architecture</em> by Uncle Bob. With that said - it's also really hard to do well in practical terms.</p>\n<p>What exactly is a single \"reason\"? This is a pretty tricky question you should answer when architecting a library.</p>\n<p>What does your library do?</p>\n<ul>\n<li>Does it define the logic of a particular domain of your application(s)?</li>\n<li>Does it define a set of reusable UI components?</li>\n<li>Does it define a set of specific components related to the business domain?</li>\n</ul>\n<p>If there is an \"and\" somewhere in your answer, then it's an indicator that you should separate the functionalities into another library.</p>\n<h3>Final Words</h3>\n<p>Nx is relatively new, and while I've seen many projects which approached it pretty well, I still have not seen one that I was entirely satisfied with.</p>\n<p>I have personally made loads of mistakes with it - it's really not as easy as it seems to lay down a perfect architecture for complex applications.</p>\n<p>As this is still something I'm trying to completely figure out, I cannot 100% recommend you follow it. If you enjoyed it, please do shoot me an email and let me know what you think of it.</p>\n<hr>\n<p><em>If you enjoyed this article, follow me on <a href=\"https://twitter.com/gc_psk\">Twitter</a></em></p>\n","coverImage":"/assets/images/posts/organize-nx-modules-ngrx.webp","collection":"angular"},"series":[],"morePosts":[{"readingTime":"2 min read","live":true,"title":"Benchmarking Angular 12 with Webpack 5","date":"2021-05-14T00:00:00.322Z","slug":"webpack-5-angular12","coverImage":"/assets/images/posts/benchmarking-webpack-5.webp","collection":"angular","excerpt":"Angular 12 has been released and with it the much awaited Webpack 5 upgrade. In this post I benchmarked the bundle-size and compilation speed against the previous version"},{"readingTime":"3 min read","live":true,"title":"Where to put your Angular models?","date":"2020-08-03T00:00:00.322Z","slug":"angular-where-to-put-models","ogImage":{"url":"/assets/images/posts/where-put-angular-models.png"},"coverImage":"/assets/images/posts/where-put-angular-models.webp","collection":"angular","excerpt":"Organizing entities and models in your Angular app may be hard. This article explains where to put your entities and what mistakes to watch out for"},{"readingTime":"5 min read","live":true,"title":"Using the Intersection Observer API with Angular","date":"2020-08-01T00:00:00.322Z","slug":"intersection-observer-with-angular","coverImage":"/assets/images/posts/intersection-observer.webp","collection":"angular","excerpt":"This article shows how to build a directive with Angular that uses the Intersection Observer API to check when an element becomes visible on the page"},{"readingTime":"3 min read","live":true,"title":"Setters vs ngOnChanges: which one is better?","date":"2020-07-30T00:00:00.322Z","slug":"setters-vs-ng-on-changes","coverImage":"/assets/images/posts/setters-vs-on-changes.webp","collection":"angular","excerpt":"Listening to Input changes can be done in different ways. But which one should you use?"},{"readingTime":"3 min read","live":true,"title":"Async Rendering with a single Rx Operator","date":"2020-07-11T00:00:00.322Z","slug":"async-rendering-with-a-single-rx-operator","coverImage":"/assets/images/posts/async-rendering.webp","collection":"angular","excerpt":"Increase your app rendering performance with this simple Rx operator"},{"readingTime":"9 min read","live":true,"title":"Building Scalable Multi-Platform Projects with Angular and Nx","date":"2019-08-25T00:00:00.322Z","slug":"building-scalable-multi-platform-projects-with-angular-and-nx","coverImage":"/assets/images/posts/scalable-multiplatform-monorepo.jpeg","collection":"angular","excerpt":"Building a scalable multi-platform monorepo application with Angular and Nx"}]},"__N_SSG":true}