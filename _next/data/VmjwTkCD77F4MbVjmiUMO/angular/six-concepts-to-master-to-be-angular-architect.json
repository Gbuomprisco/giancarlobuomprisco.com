{"pageProps":{"post":{"live":true,"readingTime":"7 min read","title":"6 Concepts to Master to be an Angular Architect","date":"2020-05-07T00:00:00.322Z","slug":"six-concepts-to-master-to-be-angular-architect","coverImage":"https://miro.medium.com/max/1400/1*MwYDKef3Nz7kcshaIGy4vQ.jpeg","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Six concepts every Angular developer should explore in-depth in order to master Angular and design well-architected applications.","content":"\nThis post was originally published, by myself, on the [Bit](https://blog.bitsrc.io) blog\n\nAngular is one of the biggest frameworks around: it provides a lot of features out-of-the-box, which means there are quite a few concepts to be able to master if from top to bottom.\n\nThere are six specific concepts I think every Angular developer should explore in-depth in order to master Angular and be able to be proficient with writing well-architected applications.\n\nNo, knowing its source code is not what’s I think it’s required — although I’ve personally had to explore in a small number of situations.\n\n## 1) Module/Library Architecture\nAngular’s Module architecture is a bit unique, and probably one of the hardest parts to fully grasp for beginners.\n\nThe most confusing concept about it is that we’re already using a module architecture on top of it: of course, I’m talking about ES imports.\n\nBecause Angular Modules add an additional layer of logical grouping, it’s important to keep them as much related as possible.\n\nBut knowing how to separate and split your app’s functionality in well-defined modules is a fundamental part of architecting Angular apps.\n\n### Different Types of Angular Modules\nThere are different types of Angular Modules you should be aware of:\n- Declarations/Widget Module (example: a module that is a collection of UI Components, Directives and Pipes)\n- Services Module (example: HttpClientModule)\n- Routing Module\n- Domain/Feature Module\n- Core/Shared Module\n\n### Library or Module?\nI would argue that we can bring this distinction at the library-level: a library with only services, a library that represents a route, and so on.\n\nBut whether you’re writing a module or a library depends a lot on your project type, and whether you are using a monorepo or a multi-repo project\n\n#### Questions to ask yourself before writing a module\nBefore writing a module, there are a few questions to ask yourself: \n\n- what sort of module am I writing? If you can’t answer this question, you should familiarize yourself with the different types of modules I listed above.It’s highly likely you’ll need one or two types of modules, so the answer may very well be two modules: Routing and Service\n\n- should this module be its own library or should it be simply a module? This is a little bit harder to answer: if you’re using a monorepo, my opinion is that building libraries would be a better option in the long run\n\n## 2) Separation of Concerns between Components, Services, and Directives\nSeparating concerns is simple in theory, and yet harder than it seems. We’ve been taught since the Angular.js days to keep components “lean” and services “fat”, and fundamentally there hasn’t been a substantial difference in the newest versions.\n\nIt is still important to understand what exactly belongs into Components and what belongs into Services, and why Directives may just be an incredibly underrated feature.\n\n### State\n\nPlacing state is a matter of understanding whether the data is accessed and shared outside of a component or whether it is local and encapsulated.\n\n- if the state is shared between components, or it needs to be accessed from services, then place your state in a service. It doesn't really matter what State Management tool you use in this case as long as it is in a service\n- if the state is local (ex. a form) and only used within a component, then simply store it in a component\n\n### DOM Manipulation\nMost DOM Manipulation should probably happen within Directives. Let’s assume you’re adding a Drag and Drop functionality to one of your components.\n\nSure, you can create a component and bind events from there, but at that point, you’re mixing two things:\n- how the component looks\n- how a certain component’s feature behaves\n\nDirectives are the ultimate reusability feature in Angular and I see them underused in almost every project I have worked on. Directives can be used to take off lots of responsibility from Components.\n\nExercise: find the largest component in your current project in terms of LOC. Does it use Renderer or ElementRef? That logic could probably be off-loaded to a directive.\n\n## 3) Change Detection and Rendering\nAngular is a fairly magic framework when it comes to re-rendering the UI.\nIt’s a different matter, though, optimizing it to only re-render when it should: it takes a bit of in-depth knowledge and intuition.\n\nAs an Angular Architect, you should probably know: OnPush Change detection is the way to go to optimize performance. But things will not always work as you expect, especially when you’re not using Observables and the async pipe within your templates.\nMastering Change Detection\n\nIn order to master change detection, it’s important to start with the following:\nTreat all your data as immutable; using Rx-Powered State Management libraries helps a lot with this\n\nUse only (or mostly) Observables to display data in your templates. If you’re using local state, use a `BehaviorSubject`\n\nMastering change detection is a mandatory step towards building extremely performant apps:\nnot only you need to make sure to update when needed, but you also need to make sure to update only when needed\n\n### Breaking through Angular’s speed limits\nReducing re-renders is one of the secrets to keeping an application fast and efficient. Sometimes, though, you may want to exceed limits for performance-critical apps: games, high-frequency updates, large and complex lists, etc.\n\nDo you need to break through Angular’s speed limits? Well, you can do that too: remove Zone and surgically update your UI thanks to Ivy’s latest features.\n\n## 4) Routing\nRouting not only allows us to organize our SPA into multiple virtual pages but also to load the application’s bundles on-demand thanks to Angular’s Routing lazy-loading features.\n\nIf you’re working on a large application and your bundles exceed 1MB, you may know why this is so important. Seriously, no one wants to download that amount of data to interact with your application.\n\nRouting should not only be used to split top-level routing, but also to drive smaller and deeper parts of your UI.\n\nThis allows you to split your bundles’ content into primary routes, but also smaller parts of the application that don’t need to be downloaded on your user’s devices until they’re requested.\n\n### Example: A tabbed component\nFor example, let’s assume you’re building a tabbed user interface, and that each tab is independent of each other: this is an ideal situation to split each tab into its own route and use lazy-loading to only load the selected tab’s content.\n\nAnother example? Popups and Modals! There is absolutely no need to load them along with your initial bundle. If the user hasn’t requested them, then only load them when they’re needed.\nIn case you need inspiration, Angular Material’s Tabs Component supports this pattern.\n\n## 5) Forms\nMost CRUD applications are basically made up of lots of forms. It’s highly likely that you may be spending a lot of time writing forms, and that’s why it’s so important to learn Angular Forms well.\n\nMost of your forms should probably be using the ReactiveFormsModule module, and do please ditch two-way data binding with ngModel unless you have one simple control.\n\nThe Angular Forms API is fairly easy to understand, and mastering it is mostly a matter of really studying the documentation and knowing its pitfalls.\n\nThe main pitfall to be aware of when working with the Forms is that it is basically untyped. It’s probably the most annoying part of an otherwise really great feature — so you’ll have to be very diligent to make sure your forms are adhering to your data structure's types.\n\n## 6) RxJS\n\nLast but not least, the infamous RxJS.\n\nI am convinced that one of Angular’s most powerful features is its deep integration with Rx and Functional Reactive Programming.\n\nTo really master Angular and unlock a great architecture, you need to first learn Rx and at least its most important operators. It’s hard to be a fully proficient Angular Developer without having spent quite a few hours understanding Rx.\n\nThere are mostly two reasons why learning Rx will benefit while writing Angular apps: Performance and Asynchronous Processing.\n\nAynchronous Processing is particularly hard in modern, highly interactive apps: forget Promise, setTimeout and setInterval and start doing things the Rx-way.\n\nAnother big reason to master Rx is optimizing performance: sure, using the Async pipe is a start, but sometimes it’s not enough. You can control re-renders by only allowing through the pipeline the events that need to be re-rendered.\n\nRx offers a variety of operators that help with caching and batching, and as a result to optimize the performance of your application:\n\n\n\n## Final Words\nThis was a short list of all the topics you need to study in-depth in order to become a highly proficient Angular developer, or to graduate to be an Architect.\n\nThere’s a lot more to this, but at the end of the day, let’s not forget that to really master anything web-related, you need to first master the basics: Javascript, CSS, Design Patterns, Clean Code, Web Tooling, etc.\n\nIf you need any clarifications, or if you think something is unclear or wrong, do please leave a comment!","canonical":"https://blog.bitsrc.io/6-concepts-to-master-to-be-an-angular-architect-807314e31ef3","tags":["angular"]},"content":{"compiledSource":"var h=Object.defineProperty,d=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var l=(e,t,o)=>t in e?h(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,i=(e,t)=>{for(var o in t||(t={}))r.call(t,o)&&l(e,o,t[o]);if(n)for(var o of n(t))s.call(t,o)&&l(e,o,t[o]);return e},p=(e,t)=>d(e,m(t));var u=(e,t)=>{var o={};for(var a in e)r.call(e,a)&&t.indexOf(a)<0&&(o[a]=e[a]);if(e!=null&&n)for(var a of n(e))t.indexOf(a)<0&&s.call(e,a)&&(o[a]=e[a]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var a=o,{components:e}=a,t=u(a,[\"components\"]);return mdx(MDXLayout,p(i(i({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"This post was originally published, by myself, on the \",mdx(\"a\",i({parentName:\"p\"},{href:\"https://blog.bitsrc.io\"}),\"Bit\"),\" blog\"),mdx(\"p\",null,\"Angular is one of the biggest frameworks around: it provides a lot of features out-of-the-box, which means there are quite a few concepts to be able to master if from top to bottom.\"),mdx(\"p\",null,\"There are six specific concepts I think every Angular developer should explore in-depth in order to master Angular and be able to be proficient with writing well-architected applications.\"),mdx(\"p\",null,\"No, knowing its source code is not what\\u2019s I think it\\u2019s required \\u2014 although I\\u2019ve personally had to explore in a small number of situations.\"),mdx(\"h2\",null,\"1) Module/Library Architecture\"),mdx(\"p\",null,\"Angular\\u2019s Module architecture is a bit unique, and probably one of the hardest parts to fully grasp for beginners.\"),mdx(\"p\",null,\"The most confusing concept about it is that we\\u2019re already using a module architecture on top of it: of course, I\\u2019m talking about ES imports.\"),mdx(\"p\",null,\"Because Angular Modules add an additional layer of logical grouping, it\\u2019s important to keep them as much related as possible.\"),mdx(\"p\",null,\"But knowing how to separate and split your app\\u2019s functionality in well-defined modules is a fundamental part of architecting Angular apps.\"),mdx(\"h3\",null,\"Different Types of Angular Modules\"),mdx(\"p\",null,\"There are different types of Angular Modules you should be aware of:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Declarations/Widget Module (example: a module that is a collection of UI Components, Directives and Pipes)\"),mdx(\"li\",{parentName:\"ul\"},\"Services Module (example: HttpClientModule)\"),mdx(\"li\",{parentName:\"ul\"},\"Routing Module\"),mdx(\"li\",{parentName:\"ul\"},\"Domain/Feature Module\"),mdx(\"li\",{parentName:\"ul\"},\"Core/Shared Module\")),mdx(\"h3\",null,\"Library or Module?\"),mdx(\"p\",null,\"I would argue that we can bring this distinction at the library-level: a library with only services, a library that represents a route, and so on.\"),mdx(\"p\",null,\"But whether you\\u2019re writing a module or a library depends a lot on your project type, and whether you are using a monorepo or a multi-repo project\"),mdx(\"h4\",null,\"Questions to ask yourself before writing a module\"),mdx(\"p\",null,\"Before writing a module, there are a few questions to ask yourself: \"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"what sort of module am I writing? If you can\\u2019t answer this question, you should familiarize yourself with the different types of modules I listed above.It\\u2019s highly likely you\\u2019ll need one or two types of modules, so the answer may very well be two modules: Routing and Service\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"should this module be its own library or should it be simply a module? This is a little bit harder to answer: if you\\u2019re using a monorepo, my opinion is that building libraries would be a better option in the long run\"))),mdx(\"h2\",null,\"2) Separation of Concerns between Components, Services, and Directives\"),mdx(\"p\",null,\"Separating concerns is simple in theory, and yet harder than it seems. We\\u2019ve been taught since the Angular.js days to keep components \\u201Clean\\u201D and services \\u201Cfat\\u201D, and fundamentally there hasn\\u2019t been a substantial difference in the newest versions.\"),mdx(\"p\",null,\"It is still important to understand what exactly belongs into Components and what belongs into Services, and why Directives may just be an incredibly underrated feature.\"),mdx(\"h3\",null,\"State\"),mdx(\"p\",null,\"Placing state is a matter of understanding whether the data is accessed and shared outside of a component or whether it is local and encapsulated.\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"if the state is shared between components, or it needs to be accessed from services, then place your state in a service. It doesn't really matter what State Management tool you use in this case as long as it is in a service\"),mdx(\"li\",{parentName:\"ul\"},\"if the state is local (ex. a form) and only used within a component, then simply store it in a component\")),mdx(\"h3\",null,\"DOM Manipulation\"),mdx(\"p\",null,\"Most DOM Manipulation should probably happen within Directives. Let\\u2019s assume you\\u2019re adding a Drag and Drop functionality to one of your components.\"),mdx(\"p\",null,\"Sure, you can create a component and bind events from there, but at that point, you\\u2019re mixing two things:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"how the component looks\"),mdx(\"li\",{parentName:\"ul\"},\"how a certain component\\u2019s feature behaves\")),mdx(\"p\",null,\"Directives are the ultimate reusability feature in Angular and I see them underused in almost every project I have worked on. Directives can be used to take off lots of responsibility from Components.\"),mdx(\"p\",null,\"Exercise: find the largest component in your current project in terms of LOC. Does it use Renderer or ElementRef? That logic could probably be off-loaded to a directive.\"),mdx(\"h2\",null,\"3) Change Detection and Rendering\"),mdx(\"p\",null,`Angular is a fairly magic framework when it comes to re-rendering the UI.\nIt\\u2019s a different matter, though, optimizing it to only re-render when it should: it takes a bit of in-depth knowledge and intuition.`),mdx(\"p\",null,`As an Angular Architect, you should probably know: OnPush Change detection is the way to go to optimize performance. But things will not always work as you expect, especially when you\\u2019re not using Observables and the async pipe within your templates.\nMastering Change Detection`),mdx(\"p\",null,`In order to master change detection, it\\u2019s important to start with the following:\nTreat all your data as immutable; using Rx-Powered State Management libraries helps a lot with this`),mdx(\"p\",null,\"Use only (or mostly) Observables to display data in your templates. If you\\u2019re using local state, use a \",mdx(\"inlineCode\",{parentName:\"p\"},\"BehaviorSubject\")),mdx(\"p\",null,`Mastering change detection is a mandatory step towards building extremely performant apps:\nnot only you need to make sure to update when needed, but you also need to make sure to update only when needed`),mdx(\"h3\",null,\"Breaking through Angular\\u2019s speed limits\"),mdx(\"p\",null,\"Reducing re-renders is one of the secrets to keeping an application fast and efficient. Sometimes, though, you may want to exceed limits for performance-critical apps: games, high-frequency updates, large and complex lists, etc.\"),mdx(\"p\",null,\"Do you need to break through Angular\\u2019s speed limits? Well, you can do that too: remove Zone and surgically update your UI thanks to Ivy\\u2019s latest features.\"),mdx(\"h2\",null,\"4) Routing\"),mdx(\"p\",null,\"Routing not only allows us to organize our SPA into multiple virtual pages but also to load the application\\u2019s bundles on-demand thanks to Angular\\u2019s Routing lazy-loading features.\"),mdx(\"p\",null,\"If you\\u2019re working on a large application and your bundles exceed 1MB, you may know why this is so important. Seriously, no one wants to download that amount of data to interact with your application.\"),mdx(\"p\",null,\"Routing should not only be used to split top-level routing, but also to drive smaller and deeper parts of your UI.\"),mdx(\"p\",null,\"This allows you to split your bundles\\u2019 content into primary routes, but also smaller parts of the application that don\\u2019t need to be downloaded on your user\\u2019s devices until they\\u2019re requested.\"),mdx(\"h3\",null,\"Example: A tabbed component\"),mdx(\"p\",null,\"For example, let\\u2019s assume you\\u2019re building a tabbed user interface, and that each tab is independent of each other: this is an ideal situation to split each tab into its own route and use lazy-loading to only load the selected tab\\u2019s content.\"),mdx(\"p\",null,`Another example? Popups and Modals! There is absolutely no need to load them along with your initial bundle. If the user hasn\\u2019t requested them, then only load them when they\\u2019re needed.\nIn case you need inspiration, Angular Material\\u2019s Tabs Component supports this pattern.`),mdx(\"h2\",null,\"5) Forms\"),mdx(\"p\",null,\"Most CRUD applications are basically made up of lots of forms. It\\u2019s highly likely that you may be spending a lot of time writing forms, and that\\u2019s why it\\u2019s so important to learn Angular Forms well.\"),mdx(\"p\",null,\"Most of your forms should probably be using the ReactiveFormsModule module, and do please ditch two-way data binding with ngModel unless you have one simple control.\"),mdx(\"p\",null,\"The Angular Forms API is fairly easy to understand, and mastering it is mostly a matter of really studying the documentation and knowing its pitfalls.\"),mdx(\"p\",null,\"The main pitfall to be aware of when working with the Forms is that it is basically untyped. It\\u2019s probably the most annoying part of an otherwise really great feature \\u2014 so you\\u2019ll have to be very diligent to make sure your forms are adhering to your data structure's types.\"),mdx(\"h2\",null,\"6) RxJS\"),mdx(\"p\",null,\"Last but not least, the infamous RxJS.\"),mdx(\"p\",null,\"I am convinced that one of Angular\\u2019s most powerful features is its deep integration with Rx and Functional Reactive Programming.\"),mdx(\"p\",null,\"To really master Angular and unlock a great architecture, you need to first learn Rx and at least its most important operators. It\\u2019s hard to be a fully proficient Angular Developer without having spent quite a few hours understanding Rx.\"),mdx(\"p\",null,\"There are mostly two reasons why learning Rx will benefit while writing Angular apps: Performance and Asynchronous Processing.\"),mdx(\"p\",null,\"Aynchronous Processing is particularly hard in modern, highly interactive apps: forget Promise, setTimeout and setInterval and start doing things the Rx-way.\"),mdx(\"p\",null,\"Another big reason to master Rx is optimizing performance: sure, using the Async pipe is a start, but sometimes it\\u2019s not enough. You can control re-renders by only allowing through the pipeline the events that need to be re-rendered.\"),mdx(\"p\",null,\"Rx offers a variety of operators that help with caching and batching, and as a result to optimize the performance of your application:\"),mdx(\"h2\",null,\"Final Words\"),mdx(\"p\",null,\"This was a short list of all the topics you need to study in-depth in order to become a highly proficient Angular developer, or to graduate to be an Architect.\"),mdx(\"p\",null,\"There\\u2019s a lot more to this, but at the end of the day, let\\u2019s not forget that to really master anything web-related, you need to first master the basics: Javascript, CSS, Design Patterns, Clean Code, Web Tooling, etc.\"),mdx(\"p\",null,\"If you need any clarifications, or if you think something is unclear or wrong, do please leave a comment!\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"series":[],"morePosts":[],"moreArticles":[{"live":true,"readingTime":"2 min read","title":"Benchmarking Angular 12 with Webpack 5","date":"2021-05-14T00:00:00.322Z","slug":"webpack-5-angular12","coverImage":"/assets/images/posts/benchmarking-webpack-5.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Angular 12 has been released and with it the much awaited Webpack 5 upgrade. In this post I benchmarked the bundle-size and compilation speed against the previous version","tags":["angular"]},{"live":true,"readingTime":"5 min read","title":"Principles for creating libraries with Nx and Angular","date":"2021-02-07T00:00:00.322Z","slug":"how-to-organize-nx-modules-with-angular","coverImage":"/assets/images/posts/organize-nx-modules-ngrx.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Working with Nx may be confusing. This article explains how I create Nx libraries and the principles behind my motivations","tags":["nx","angular"]},{"live":true,"readingTime":"3 min read","title":"Where to put your Angular models?","date":"2020-08-03T00:00:00.322Z","slug":"angular-where-to-put-models","ogImage":{"url":"/assets/images/posts/where-put-angular-models.png"},"coverImage":"/assets/images/posts/where-put-angular-models.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Organizing entities and models in your Angular app may be hard. This article explains where to put your entities and what mistakes to watch out for","tags":["angular","architecture"]},{"live":true,"readingTime":"5 min read","title":"Using the Intersection Observer API with Angular","date":"2020-08-01T00:00:00.322Z","slug":"intersection-observer-with-angular","coverImage":"/assets/images/posts/intersection-observer.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"This article shows how to build a directive with Angular that uses the Intersection Observer API to check when an element becomes visible on the page","tags":["angular","performance"]},{"live":true,"readingTime":"3 min read","title":"Setters vs ngOnChanges: which one is better?","date":"2020-07-30T00:00:00.322Z","slug":"setters-vs-ng-on-changes","coverImage":"/assets/images/posts/setters-vs-on-changes.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Listening to Input changes can be done in different ways. But which one should you use?","tags":["angular"]},{"live":true,"readingTime":"3 min read","title":"Async Rendering with a single Rx Operator","date":"2020-07-11T00:00:00.322Z","slug":"async-rendering-with-a-single-rx-operator","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Increase your app rendering performance with this simple Rx operator","tags":["angular","rxjs"]}],"type":1},"__N_SSG":true}