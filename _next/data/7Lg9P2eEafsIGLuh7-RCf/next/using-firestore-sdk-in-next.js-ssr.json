{"pageProps":{"post":{"live":true,"readingTime":"3 min read","title":"Using Firestore's SDK in Next.js's SSR","date":"2021-11-27T16:30:30.000Z","slug":"using-firestore-sdk-in-next.js-ssr","collection":{"name":"Next","primaryColor":"#111","primaryColorLight":"#111111a6","contrastColor":"#ffffff","logo":"/assets/images/collections/next.webp"},"content":"As I'm venturing into using Next.js to build a Saas boilerplate (coming soon), I'm beginning to understand that while SSR is fantastic, it has a ton of gotchas you need to know before thinking of adopting it.\n\nAfter spending the better part of my day trying to server-render a component that uses the Firebase SDK, I thought this write-up could help other people.\n\nSo, what's the issue?\n\nFirebase has always had a messy relationship with Javascript SDKs. There are many, and they're confusing. The newest v9 version does help a bit, but it made my issue worse.\n\nMy code uses `reactfire` to render a FirebaseAppProvider component which initializes a new Firebase App and creates a Context so that you can use `useFirebaseApp` to use the app throughout the application.\n\nOne of my components is making a Firestore query, which gets rendered on the server for obvious reasons. However, even if the query doesn't return a result, being asynchronous, it will still call the SDK.\n\nIf you're using the Reactfire example, you may be initializing your component in this way:\n\n```typescript\n<FirebaseAppProvider firebaseConfig={config}>  \n  {children}  \n</FirebaseAppProvider>\n```\n\nBut then I was met with the following error:\n\n    FirebaseError: Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore\n\nAt first, I thought the `Firestore` instance using `useFirestore` became `null` before or after a re-render. That was wrong.\n\nThe instance was fine; the issue was deep down the Firestore's SDK.\n\nWhat happens? Firestore checks that the Firestore instance was created using the same SDK, even if it is perfectly working. If it's not, then it will throw this somewhat cryptic error.\n\nIt can happen when a Firebase/Firestore instance gets created by another version of the Firebase SDK. Instead of letting `reactfire` create the Firebase instance for me, and I decided to pass it down manually.\n\nThe code above becomes:\n\n```typescript\nconst app = initializeApp(config);\n\nreturn (\n \t<FirebaseAppProvider firebaseApp={app}>\n    \t{children}\n\t</FirebaseAppProvider>\n);\n```\n\nThe error changes, still no luck.\n\n    FirebaseError: Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?\n\nBut I feel like I'm getting closer, as the issue now comes from the actual query call, a few lines down.\n\nMy feeling at this point is that Firebase is initializing Firestore using the ESM version of the SDK, yet executing the query using the CommonJS version.\n\nThis is where the stack trace points to:\n\n    file:///Users/giancarlo/Code/project/node_modules/@firebase/firestore/dist/index.node.cjs.js (18550:19)\n\nFirestore uses a function `cast` to check that the instance is the one from the same library. I have not confirmed this yet with the team, but I believe `rxfire` using the wrong version to perform queries; `reactfire` uses `rxfire` under the hood. If you're not using `reactfire` , there is a good chance your code would have worked fine.\n\n## The solution\n\nAt this point, I try to play with Next.js's options. If use `type: \"module\"` in my `package.json`, I could force `rxfire` to use the ESM version? This opened a can of worms, so I ditched the possibility for the time being.\n\nThen I tried to disable one of Next.js 12's experimental features that got turned on by default in the latest release.\n\nI changed the `next.config.js` configuration file and set the `esmExternals` property to `true`.\n\n    experimental: {\n      esmExternals: true,\n    }\n\nI could not believe my eyes: after several hours of debugging and head-scratching, I got the Firestore SDK to work with SSR.\n\nThe issue is that without `Suspense` my queries aren't working - so they get only fetched on the client, but for now, it's good enough.\n\nI'll try Suspense's beta soon: enough head-scratching for today.","tags":["next","firebase","react"]},"content":{"compiledSource":"var d=Object.defineProperty,m=Object.defineProperties;var h=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var p=(a,n,t)=>n in a?d(a,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[n]=t,e=(a,n)=>{for(var t in n||(n={}))r.call(n,t)&&p(a,t,n[t]);if(s)for(var t of s(n))i.call(n,t)&&p(a,t,n[t]);return a},c=(a,n)=>m(a,h(n));var l=(a,n)=>{var t={};for(var o in a)r.call(a,o)&&n.indexOf(o)<0&&(t[o]=a[o]);if(a!=null&&s)for(var o of s(a))n.indexOf(o)<0&&i.call(a,o)&&(t[o]=a[o]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var o=t,{components:a}=o,n=l(o,[\"components\"]);return mdx(MDXLayout,c(e(e({},layoutProps),n),{components:a,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"As I'm venturing into using Next.js to build a Saas boilerplate (coming soon), I'm beginning to understand that while SSR is fantastic, it has a ton of gotchas you need to know before thinking of adopting it.\"),mdx(\"p\",null,\"After spending the better part of my day trying to server-render a component that uses the Firebase SDK, I thought this write-up could help other people.\"),mdx(\"p\",null,\"So, what's the issue?\"),mdx(\"p\",null,\"Firebase has always had a messy relationship with Javascript SDKs. There are many, and they're confusing. The newest v9 version does help a bit, but it made my issue worse.\"),mdx(\"p\",null,\"My code uses \",mdx(\"inlineCode\",{parentName:\"p\"},\"reactfire\"),\" to render a FirebaseAppProvider component which initializes a new Firebase App and creates a Context so that you can use \",mdx(\"inlineCode\",{parentName:\"p\"},\"useFirebaseApp\"),\" to use the app throughout the application.\"),mdx(\"p\",null,\"One of my components is making a Firestore query, which gets rendered on the server for obvious reasons. However, even if the query doesn't return a result, being asynchronous, it will still call the SDK.\"),mdx(\"p\",null,\"If you're using the Reactfire example, you may be initializing your component in this way:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<\"),\"FirebaseAppProvider firebaseConfig\",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),\"config\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\">\"),`  \n  `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),\"children\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`  \n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"/\"),\"FirebaseAppProvider\",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\">\"),`\n`))),mdx(\"p\",null,\"But then I was met with the following error:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),\"FirebaseError: Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore\"))),mdx(\"p\",null,\"At first, I thought the \",mdx(\"inlineCode\",{parentName:\"p\"},\"Firestore\"),\" instance using \",mdx(\"inlineCode\",{parentName:\"p\"},\"useFirestore\"),\" became \",mdx(\"inlineCode\",{parentName:\"p\"},\"null\"),\" before or after a re-render. That was wrong.\"),mdx(\"p\",null,\"The instance was fine; the issue was deep down the Firestore's SDK.\"),mdx(\"p\",null,\"What happens? Firestore checks that the Firestore instance was created using the same SDK, even if it is perfectly working. If it's not, then it will throw this somewhat cryptic error.\"),mdx(\"p\",null,\"It can happen when a Firebase/Firestore instance gets created by another version of the Firebase SDK. Instead of letting \",mdx(\"inlineCode\",{parentName:\"p\"},\"reactfire\"),\" create the Firebase instance for me, and I decided to pass it down manually.\"),mdx(\"p\",null,\"The code above becomes:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" app \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"initializeApp\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"config\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"return\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),`\n \t`,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<\"),\"FirebaseAppProvider firebaseApp\",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),\"app\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\">\"),`\n    \t`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),\"children\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n\t`,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"/\"),\"FirebaseAppProvider\",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\">\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`))),mdx(\"p\",null,\"The error changes, still no luck.\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),\"FirebaseError: Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?\"))),mdx(\"p\",null,\"But I feel like I'm getting closer, as the issue now comes from the actual query call, a few lines down.\"),mdx(\"p\",null,\"My feeling at this point is that Firebase is initializing Firestore using the ESM version of the SDK, yet executing the query using the CommonJS version.\"),mdx(\"p\",null,\"This is where the stack trace points to:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),\"file:///Users/giancarlo/Code/project/node_modules/@firebase/firestore/dist/index.node.cjs.js (18550:19)\"))),mdx(\"p\",null,\"Firestore uses a function \",mdx(\"inlineCode\",{parentName:\"p\"},\"cast\"),\" to check that the instance is the one from the same library. I have not confirmed this yet with the team, but I believe \",mdx(\"inlineCode\",{parentName:\"p\"},\"rxfire\"),\" using the wrong version to perform queries; \",mdx(\"inlineCode\",{parentName:\"p\"},\"reactfire\"),\" uses \",mdx(\"inlineCode\",{parentName:\"p\"},\"rxfire\"),\" under the hood. If you're not using \",mdx(\"inlineCode\",{parentName:\"p\"},\"reactfire\"),\" , there is a good chance your code would have worked fine.\"),mdx(\"h2\",null,\"The solution\"),mdx(\"p\",null,\"At this point, I try to play with Next.js's options. If use \",mdx(\"inlineCode\",{parentName:\"p\"},'type: \"module\"'),\" in my \",mdx(\"inlineCode\",{parentName:\"p\"},\"package.json\"),\", I could force \",mdx(\"inlineCode\",{parentName:\"p\"},\"rxfire\"),\" to use the ESM version? This opened a can of worms, so I ditched the possibility for the time being.\"),mdx(\"p\",null,\"Then I tried to disable one of Next.js 12's experimental features that got turned on by default in the latest release.\"),mdx(\"p\",null,\"I changed the \",mdx(\"inlineCode\",{parentName:\"p\"},\"next.config.js\"),\" configuration file and set the \",mdx(\"inlineCode\",{parentName:\"p\"},\"esmExternals\"),\" property to \",mdx(\"inlineCode\",{parentName:\"p\"},\"true\"),\".\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),`experimental: {\n  esmExternals: true,\n}`))),mdx(\"p\",null,\"I could not believe my eyes: after several hours of debugging and head-scratching, I got the Firestore SDK to work with SSR.\"),mdx(\"p\",null,\"The issue is that without \",mdx(\"inlineCode\",{parentName:\"p\"},\"Suspense\"),\" my queries aren't working - so they get only fetched on the client, but for now, it's good enough.\"),mdx(\"p\",null,\"I'll try Suspense's beta soon: enough head-scratching for today.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"series":[],"morePosts":[],"moreArticles":[],"type":0},"__N_SSG":true}