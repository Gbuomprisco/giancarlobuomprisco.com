{"pageProps":{"post":{"live":true,"readingTime":"2 min read","title":"Benchmarking Angular 12 with Webpack 5","date":"2021-05-14T00:00:00.322Z","slug":"webpack-5-angular12","coverImage":"/assets/images/posts/benchmarking-webpack-5.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Angular 12 has been released and with it the much awaited Webpack 5 upgrade. In this post I benchmarked the bundle-size and compilation speed against the previous version","content":"\n**Angular 12** has just been released! Yay!\n\nThis is a particularly long-awaited release due to the CLI using Webpack 5 by default, which comes with improved performance and tree-shaking - or at least that's the promise.\n\nThat means, faster and smaller builds. Who doesn't like that?\n\nI took the time to benchmark 2 apps I work on, one small and another medium-sized: read on to see the results.\n\n**Notice:**: The results can differ wildly given your setup and applications, so please don't take this benchmarks too seriously.\n\nActually, I'd love to know what your results will end up being!\n\n### Setup\n\nThe tests have been done on a Macbook Pro 2018 i7 2.2Ghz 32Gb RAM - using Node v16.\n\n- The Webpack 4 builds are built using Angular 11.2.12.\n- The Webpack 5 builds are built using Angular 12.0.0.\n\n## Webpack 5 vs Webpack 4: Small Application benchmark\n\n### Development Build Time\n\nThe following graph shows the results for the **initial** development build time.\n\n- Webpack 4: 30.1 seconds\n- Webpack 5: 32.9 seconds\n\nAs you can see, the new Webpack version falls behind nearly 3 seconds - which is a bit of a bummer.\n\n### Production Build Time\n\nThe following graph shows the results for the production build time. The version 5 makes up for falling behind in the development build.\n\n```bar-chart\nVersion, Time in Seconds\nWebpack 4,58.1\nWebpack 5,51.8\n```\n\n- Webpack 4: 58.1 seconds\n- Webpack 5: 51.8 seconds\n\nI was positively impressed by this one, 7 seconds is pretty noticeable.\n\n### Production Bundle Size\n\nThe following graph shows the results for the total production bundle size.\n\nThat means, we take into account the total size of all the initial assets (main, styles, polyfills, runtime).\n\nThe total size is **not** gzipped.\n\n- Webpack 4: 833.29kb\n- Webpack 5: 830.19kb\n\nWebpack 5 wins the production race - although maybe not by as much as we'd all hoped!\n\n## Webpack 5 vs Webpack 4: Large Application benchmark\n\n### Development Build Time\n\n- Webpack 4: 74 seconds\n- Webpack 5: 84.5 seconds\n\n10 seconds longer for starting the development build is unfortunately a lot more.\n\n### Production Build Time\n\nThe following graph shows the results for the production build time. The version 5 makes up for falling behind in the development build.\n\n- Webpack 4: 1 minute 37 seconds\n- Webpack 5: 1 minute 34 seconds\n\n### Production Bundle Size\n\n- Webpack 4: 1.961Mb\n- Webpack 5: 1.970Mb\n\n***\n\nIf you want, do shoot me an email and let me know what your results will look like!\n\n_If you enjoyed this article, follow me on [Twitter](https://twitter.com/gc_psk)_\n"},"content":{"compiledSource":"var h=Object.defineProperty,c=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var p=(e,a,t)=>a in e?h(e,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[a]=t,i=(e,a)=>{for(var t in a||(a={}))o.call(a,t)&&p(e,t,a[t]);if(n)for(var t of n(a))s.call(a,t)&&p(e,t,a[t]);return e},r=(e,a)=>c(e,m(a));var u=(e,a)=>{var t={};for(var l in e)o.call(e,l)&&a.indexOf(l)<0&&(t[l]=e[l]);if(e!=null&&n)for(var l of n(e))a.indexOf(l)<0&&s.call(e,l)&&(t[l]=e[l]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var l=t,{components:e}=l,a=u(l,[\"components\"]);return mdx(MDXLayout,r(i(i({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Angular 12\"),\" has just been released! Yay!\"),mdx(\"p\",null,\"This is a particularly long-awaited release due to the CLI using Webpack 5 by default, which comes with improved performance and tree-shaking - or at least that's the promise.\"),mdx(\"p\",null,\"That means, faster and smaller builds. Who doesn't like that?\"),mdx(\"p\",null,\"I took the time to benchmark 2 apps I work on, one small and another medium-sized: read on to see the results.\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Notice:\"),\": The results can differ wildly given your setup and applications, so please don't take this benchmarks too seriously.\"),mdx(\"p\",null,\"Actually, I'd love to know what your results will end up being!\"),mdx(\"h3\",null,\"Setup\"),mdx(\"p\",null,\"The tests have been done on a Macbook Pro 2018 i7 2.2Ghz 32Gb RAM - using Node v16.\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"The Webpack 4 builds are built using Angular 11.2.12.\"),mdx(\"li\",{parentName:\"ul\"},\"The Webpack 5 builds are built using Angular 12.0.0.\")),mdx(\"h2\",null,\"Webpack 5 vs Webpack 4: Small Application benchmark\"),mdx(\"h3\",null,\"Development Build Time\"),mdx(\"p\",null,\"The following graph shows the results for the \",mdx(\"strong\",{parentName:\"p\"},\"initial\"),\" development build time.\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Webpack 4: 30.1 seconds\"),mdx(\"li\",{parentName:\"ul\"},\"Webpack 5: 32.9 seconds\")),mdx(\"p\",null,\"As you can see, the new Webpack version falls behind nearly 3 seconds - which is a bit of a bummer.\"),mdx(\"h3\",null,\"Production Build Time\"),mdx(\"p\",null,\"The following graph shows the results for the production build time. The version 5 makes up for falling behind in the development build.\"),mdx(\"div\",i({},{className:\"remark-highlight\"}),mdx(\"pre\",i({parentName:\"div\"},{className:\"language-bar-chart\"}),mdx(\"code\",i({parentName:\"pre\"},{className:\"language-bar-chart\"}),`Version, Time in Seconds\nWebpack 4,58.1\nWebpack 5,51.8`))),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Webpack 4: 58.1 seconds\"),mdx(\"li\",{parentName:\"ul\"},\"Webpack 5: 51.8 seconds\")),mdx(\"p\",null,\"I was positively impressed by this one, 7 seconds is pretty noticeable.\"),mdx(\"h3\",null,\"Production Bundle Size\"),mdx(\"p\",null,\"The following graph shows the results for the total production bundle size.\"),mdx(\"p\",null,\"That means, we take into account the total size of all the initial assets (main, styles, polyfills, runtime).\"),mdx(\"p\",null,\"The total size is \",mdx(\"strong\",{parentName:\"p\"},\"not\"),\" gzipped.\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Webpack 4: 833.29kb\"),mdx(\"li\",{parentName:\"ul\"},\"Webpack 5: 830.19kb\")),mdx(\"p\",null,\"Webpack 5 wins the production race - although maybe not by as much as we'd all hoped!\"),mdx(\"h2\",null,\"Webpack 5 vs Webpack 4: Large Application benchmark\"),mdx(\"h3\",null,\"Development Build Time\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Webpack 4: 74 seconds\"),mdx(\"li\",{parentName:\"ul\"},\"Webpack 5: 84.5 seconds\")),mdx(\"p\",null,\"10 seconds longer for starting the development build is unfortunately a lot more.\"),mdx(\"h3\",null,\"Production Build Time\"),mdx(\"p\",null,\"The following graph shows the results for the production build time. The version 5 makes up for falling behind in the development build.\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Webpack 4: 1 minute 37 seconds\"),mdx(\"li\",{parentName:\"ul\"},\"Webpack 5: 1 minute 34 seconds\")),mdx(\"h3\",null,\"Production Bundle Size\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Webpack 4: 1.961Mb\"),mdx(\"li\",{parentName:\"ul\"},\"Webpack 5: 1.970Mb\")),mdx(\"hr\",null),mdx(\"p\",null,\"If you want, do shoot me an email and let me know what your results will look like!\"),mdx(\"p\",null,mdx(\"em\",{parentName:\"p\"},\"If you enjoyed this article, follow me on \",mdx(\"a\",i({parentName:\"em\"},{href:\"https://twitter.com/gc_psk\"}),\"Twitter\"))))}MDXContent.isMDXComponent=!0;\n","scope":{}},"series":[],"morePosts":[],"moreArticles":[{"live":true,"readingTime":"5 min read","title":"Principles for creating libraries with Nx and Angular","date":"2021-02-07T00:00:00.322Z","slug":"how-to-organize-nx-modules-with-angular","coverImage":"/assets/images/posts/organize-nx-modules-ngrx.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Working with Nx may be confusing. This article explains how I create Nx libraries and the principles behind my motivations","tags":["nx","angular"]},{"live":true,"readingTime":"3 min read","title":"Where to put your Angular models?","date":"2020-08-03T00:00:00.322Z","slug":"angular-where-to-put-models","ogImage":{"url":"/assets/images/posts/where-put-angular-models.png"},"coverImage":"/assets/images/posts/where-put-angular-models.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Organizing entities and models in your Angular app may be hard. This article explains where to put your entities and what mistakes to watch out for","tags":["angular","architecture"]},{"live":true,"readingTime":"5 min read","title":"Using the Intersection Observer API with Angular","date":"2020-08-01T00:00:00.322Z","slug":"intersection-observer-with-angular","coverImage":"/assets/images/posts/intersection-observer.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"This article shows how to build a directive with Angular that uses the Intersection Observer API to check when an element becomes visible on the page","tags":["angular","performance"]},{"live":true,"readingTime":"3 min read","title":"Setters vs ngOnChanges: which one is better?","date":"2020-07-30T00:00:00.322Z","slug":"setters-vs-ng-on-changes","coverImage":"/assets/images/posts/setters-vs-on-changes.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Listening to Input changes can be done in different ways. But which one should you use?","tags":["angular"]},{"live":true,"readingTime":"3 min read","title":"Async Rendering with a single Rx Operator","date":"2020-07-11T00:00:00.322Z","slug":"async-rendering-with-a-single-rx-operator","coverImage":"/assets/images/posts/async-rendering.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Increase your app rendering performance with this simple Rx operator","tags":["angular","rxjs"]},{"live":true,"readingTime":"6 min read","title":"3 Ways to Render Large Lists in Angular","date":"2020-05-09T00:00:00.322Z","slug":"three-ways-render-large-lists-angular","coverImage":"https://cdn-images-1.medium.com/max/2560/1*URBd9pgYJGC0vhqthQ-z8g.jpeg","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"An overview of the available techniques to render large lists of items with Angular","tags":["angular","performance"]}],"type":1},"__N_SSG":true}