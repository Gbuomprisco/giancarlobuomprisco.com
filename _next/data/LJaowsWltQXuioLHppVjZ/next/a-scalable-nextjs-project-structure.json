{"pageProps":{"post":{"live":true,"readingTime":"7 min read","title":"A Scalable Project Structure for Next.js","date":"2021-12-10T00:00:00.000Z","slug":"a-scalable-nextjs-project-structure","collection":{"name":"Next","primaryColor":"#111","primaryColorLight":"#111111a6","contrastColor":"#ffffff","logo":"/assets/images/collections/next.webp","slug":"next"},"excerpt":"Next.js and React are not opinionated. Much is left to us to figure out - and without rules, our code can get wild pretty quickly. In this post I explain the rationale behind the way I structure my Next.js projects for small and medium-sized apps","content":"\nAs a programmer, and like many of my colleagues, I am obsessed with neat, scalable folder structures.\n\nHaving dabbled with Angular for a good part of my career, I had become accustomed to splitting the codebase into separate libraries, usually using a monorepo build-system like Nx or even the built-in provided by the CLI.\n\nBut, React is a different, slightly wilder world.\n\nWhile monorepos exist and are used by some, it's clear that the trend is nowhere near on the blue side of the pond.\n\nHaving an instantly recognizable codebase is more important to me than having it the way I'm used to.\n\nThat's why I'm trying to get out of my comfort zone and embrace something in the middle. With that said, I still think using a monorepo is the best decision for an enterprise team, using any technology. I'll talk more about that in another article.\n\nIn this article, I want to show a **neat, scalable folder structure for solo-developers or small teams using Next.js** ideal for medium-sized web apps. A simple structure that is simple enough not to cause analysis-paralysis, but that can scale just fine wih your project.\n\n## Where is the domain?\n\nSomething that has left me slightly perplexed is the blurry line between the domain and the core of a project in most projects I've seen. Not meaning in a bad way: it's simply a bit foreign to me.\n\nBut what is a **business domain**? The business domain is the group of entities, their relationships and behaviors of the **business model**, implemented as code.\n\nLet's assume we are building an application about booking events; here are some entities that are part of our domain:\n\n- Event\n- Person\n- Place\n- ...and more\n\nThe core and the domain of a project, in my view, should be kept well separate.  Let's see how.\n\n## The structure\n\nFirst, I recommend using the `src` folder (which Next.js supports without additional configuration) without a specific reason. I prefer to keep code at a different level than configurations and miscellaneous files. Call me weird.\n\nBelow, you can find the onion-shaped structure I use for my Next.js projects:\n\n<Image data-shadowless src='/assets/images/posts/nextjs-folder-structure-onion.png' /> \n\nWe can express the above image with the following project structure:\n\n```\n- src\n  - core\n  - components\n  - lib\n  - pages\n    - api\n```\n\n### Core\n\nThe core layer is where we place everything unrelated to our domain, such as utilities, technical implementations, or API.\n\nFor example:\n- the functions that connect to your database\n- the utilities that you use to authenticate users\n- the provider to send emails\n- the reusable UI components not related to any domain (ex. Dropdown, Button, TextInput)\n- etc.\n\nAs you can see, there is very little about these concepts that scream \"domain\". \n\nThe `core layer` provides the domain with the necessary tools for the application to work, for example, authenticating, querying the DB, or sending emails. But does not know how the consumer will use these tools.\n\nHard rule: **the core layer can never import anything from the domain layer**`. \n\nIf something within the core layer needs something from the domain, it probably does not belong to the core layer.\n\nThis is typically something that can be abstracted into external libraries, also to make it easier to define a restricted public API which becomes much harder when our only separation is a folder (which is why I would recommend setting up `eslint` with a way to prevent such imports, as we will see).\n\nWhat are examples of code that belongs to `core`?\n\nLet's assume you use Firebase, and that you need to connect to `Firestore` to fetch data: initializing the database, connecting to it, etc. is what I would regard as being the core of the application. The way the database will be used is completely independent.\n\nBy following a core/domain approach, you **will also increase the reusability of your utilities and make it pretty easy to reuse across projects**.\n\n### Lib\nI have to be honest: I do not know why I'm calling this `lib.` In Angular-land, it would be `modules.`\n\nBut every codebase I've seen had `lib` for business-logic code. So I stuck with it. As I said, familiarity is essential.\n\nWhat should we add to this library? Anything about the domain that isn't a component, like:\n- queries\n- mutations\n- custom hooks\n- contexts\n- props functions (getServerSideProps, getInitialProps)\n\nThese utilities are normally used within `Components` (for the most part) and partly within the pages for functions such as `getServerSideProps`.\n\nFor example, `lib` could expose the props `user/with-user-props.ts` which is a function returning the current session to the page where it's used.\n\nThe `lib` and `components` folders can be further splitted by `entities`. \n\nWe could develop our folder structure in this way:\n\n```\n- src\n  - lib\n    - events\n      - hooks\n      - queries\n      - mutations\n      - utils\n      - server\n      - ...\n    - places\n      - hooks\n      - queries\n      - ...\n\n  - components\n    - events\n      - CreateEventForm.tsx\n      - EventsActionsDropdown.tsx\n    - places\n      - EditPlaceForm.tsx\n```\n\n### Components\n\nThis folder is, logically, on the same layer as `lib`. The reason why I do not place them in the same folder is to avoid excessive nesting, which can become nasty. \n\nAs you may have imagined, here we can place the components that make up our pages. These are components that are highly tied to the domain, and are not supposed to be *that* reusable across projects. \n\nThey're business-logic rich, and are built using the UI components from `core`.\n\nThe business-logic side of things, such as queries, or functions that mutate data, are all imported from `lib`, so that they can be reusable across components.\n\nFor example, the component `CreateEventForm` know about the domain, and uses a `mutation` to create an event. This is all domain-dependent, and as such will be placed within `components`, rather than `core`.\n\n### Pages\n\nIf you know Next, you may not need an explanation for this. This is a Next.js specific folder where we place our routes/pages. \n\nNext.js's router is file-system based: so, yes, no configurations. It's all driven by how we structure the pages in this folder.\n\nOf course, this is highly dependent on the domain of your application.\n\n```\n- pages\n  - api\n    - events\n      - [event].tsx // will import from lib/server/events\n  - events\n    - [event].tsx // will import from lib/events and components/events\n```\n\n## Imports between Layers\n\nSomething important to clarify is the rules I have in place around importing between layers. \n\nNormally, an inner layer cannot import from an outer layer: that means that `core` cannot impor from `lib` and `components` and the latter cannot import from `pages`.\n\n<Image data-shadowless src='/assets/images/posts/next-structure-imports-wrong.png' /> \n<Image data-shadowless src='/assets/images/posts/next-structure-imports.png' /> \n\nThis will ensure your `core` is clearly decoupled from the domain, to avoid cyclical dependencies, and to keep your architecture untangled. I know first-hand how messy it can get when your imports have no rules at all.\n\n### Linting import paths with EsLint\n\nThat's cool. But how can we make sure that we're using the rules above correctly when importing files in our application?\n\nEsLint can help us by adding a rule to lint our imports. \n\nBy adding the following configuration to yours, you will be automatically warned when you're importing from the wrong paths:\n\n```json\n\"rules\": {\n  \"import/no-restricted-paths\": [\n    \"error\",\n    {\n      \"zones\": [\n        {\n          \"target\": \"./src/core\",\n          \"from\": \"./src/components\"\n        },\n        {\n          \"target\": \"./src/core\",\n          \"from\": \"./src/lib\"\n        },\n        {\n          \"target\": \"./src/core\",\n          \"from\": \"./src/pages\"\n        },\n        {\n          \"target\": \"./src/lib\",\n          \"from\": \"./src/pages\"\n        },\n        {\n          \"target\": \"./src/components\",\n          \"from\": \"./src/pages\"\n        }\n      ]\n    }\n  ]\n}\n```\n\nAssuming I was importing a page from `pages` into any file within `lib`, `components` or `core`, I would see an error such as the below:\n\n<Image data-shadowless src='/assets/images/posts/eslint-import-error-next.png' /> \n\nIf you find the rule too verbose, just replace `error` with `warning`.\n\n## Final Words\n\nWhether you use this or another approach, remember that the important part of setting up a folder structure is that **it needs to work well for you and your use case**: it shouldn't be a simple mess, nor should it be so complex you spend an hour to decide where to place a file. \n\nThat's simply detrimental to your productivity, and it usually means you either have placed no rules at all, or your rules are way too strict.\n\nIf you think this through with your team and agree a couple of rules, it will help with keeping the codebase familiar to everyone, avoid needless (but sometimes unavoidable) team arguments, and ultimately **keep you and the codebase as sane as possible**.\n\n#### Small, but ambitious apps\n\nThis is my take: it's for small, but still ambitious apps. \n\nFor larger, enterprise apps, I still think that a monorepo would be more beneficial (especially for teams who maintain more apps). \n\nBut most apps aren't enteprise: if your goal is to get started with the right foot, ship quickly and well, give this a try.\n\nFor any comment, or suggestions, please send me an email. Ciao!","tags":["next","react"],"ogImage":{"url":"/assets/images/posts/a-scalable-nextjs-project-structure.webp"}},"content":{"compiledSource":"var c=Object.defineProperty,d=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var p=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var r=(a,n,t)=>n in a?c(a,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[n]=t,e=(a,n)=>{for(var t in n||(n={}))p.call(n,t)&&r(a,t,n[t]);if(s)for(var t of s(n))i.call(n,t)&&r(a,t,n[t]);return a},l=(a,n)=>d(a,u(n));var m=(a,n)=>{var t={};for(var o in a)p.call(a,o)&&n.indexOf(o)<0&&(t[o]=a[o]);if(a!=null&&s)for(var o of s(a))n.indexOf(o)<0&&i.call(a,o)&&(t[o]=a[o]);return t};const makeShortcode=a=>function(t){return console.warn(\"Component \"+a+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",e({},t))},Image=makeShortcode(\"Image\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var o=t,{components:a}=o,n=m(o,[\"components\"]);return mdx(MDXLayout,l(e(e({},layoutProps),n),{components:a,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"As a programmer, and like many of my colleagues, I am obsessed with neat, scalable folder structures.\"),mdx(\"p\",null,\"Having dabbled with Angular for a good part of my career, I had become accustomed to splitting the codebase into separate libraries, usually using a monorepo build-system like Nx or even the built-in provided by the CLI.\"),mdx(\"p\",null,\"But, React is a different, slightly wilder world.\"),mdx(\"p\",null,\"While monorepos exist and are used by some, it's clear that the trend is nowhere near on the blue side of the pond.\"),mdx(\"p\",null,\"Having an instantly recognizable codebase is more important to me than having it the way I'm used to.\"),mdx(\"p\",null,\"That's why I'm trying to get out of my comfort zone and embrace something in the middle. With that said, I still think using a monorepo is the best decision for an enterprise team, using any technology. I'll talk more about that in another article.\"),mdx(\"p\",null,\"In this article, I want to show a \",mdx(\"strong\",{parentName:\"p\"},\"neat, scalable folder structure for solo-developers or small teams using Next.js\"),\" ideal for medium-sized web apps. A simple structure that is simple enough not to cause analysis-paralysis, but that can scale just fine wih your project.\"),mdx(\"h2\",null,\"Where is the domain?\"),mdx(\"p\",null,\"Something that has left me slightly perplexed is the blurry line between the domain and the core of a project in most projects I've seen. Not meaning in a bad way: it's simply a bit foreign to me.\"),mdx(\"p\",null,\"But what is a \",mdx(\"strong\",{parentName:\"p\"},\"business domain\"),\"? The business domain is the group of entities, their relationships and behaviors of the \",mdx(\"strong\",{parentName:\"p\"},\"business model\"),\", implemented as code.\"),mdx(\"p\",null,\"Let's assume we are building an application about booking events; here are some entities that are part of our domain:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Event\"),mdx(\"li\",{parentName:\"ul\"},\"Person\"),mdx(\"li\",{parentName:\"ul\"},\"Place\"),mdx(\"li\",{parentName:\"ul\"},\"...and more\")),mdx(\"p\",null,\"The core and the domain of a project, in my view, should be kept well separate.  Let's see how.\"),mdx(\"h2\",null,\"The structure\"),mdx(\"p\",null,\"First, I recommend using the \",mdx(\"inlineCode\",{parentName:\"p\"},\"src\"),\" folder (which Next.js supports without additional configuration) without a specific reason. I prefer to keep code at a different level than configurations and miscellaneous files. Call me weird.\"),mdx(\"p\",null,\"Below, you can find the onion-shaped structure I use for my Next.js projects:\"),mdx(Image,{\"data-shadowless\":!0,src:\"/assets/images/posts/nextjs-folder-structure-onion.png\",mdxType:\"Image\"}),mdx(\"p\",null,\"We can express the above image with the following project structure:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),`- src\n  - core\n  - components\n  - lib\n  - pages\n    - api`))),mdx(\"h3\",null,\"Core\"),mdx(\"p\",null,\"The core layer is where we place everything unrelated to our domain, such as utilities, technical implementations, or API.\"),mdx(\"p\",null,\"For example:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"the functions that connect to your database\"),mdx(\"li\",{parentName:\"ul\"},\"the utilities that you use to authenticate users\"),mdx(\"li\",{parentName:\"ul\"},\"the provider to send emails\"),mdx(\"li\",{parentName:\"ul\"},\"the reusable UI components not related to any domain (ex. Dropdown, Button, TextInput)\"),mdx(\"li\",{parentName:\"ul\"},\"etc.\")),mdx(\"p\",null,'As you can see, there is very little about these concepts that scream \"domain\". '),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"core layer\"),\" provides the domain with the necessary tools for the application to work, for example, authenticating, querying the DB, or sending emails. But does not know how the consumer will use these tools.\"),mdx(\"p\",null,\"Hard rule: \",mdx(\"strong\",{parentName:\"p\"},\"the core layer can never import anything from the domain layer\"),\"`. \"),mdx(\"p\",null,\"If something within the core layer needs something from the domain, it probably does not belong to the core layer.\"),mdx(\"p\",null,\"This is typically something that can be abstracted into external libraries, also to make it easier to define a restricted public API which becomes much harder when our only separation is a folder (which is why I would recommend setting up \",mdx(\"inlineCode\",{parentName:\"p\"},\"eslint\"),\" with a way to prevent such imports, as we will see).\"),mdx(\"p\",null,\"What are examples of code that belongs to \",mdx(\"inlineCode\",{parentName:\"p\"},\"core\"),\"?\"),mdx(\"p\",null,\"Let's assume you use Firebase, and that you need to connect to \",mdx(\"inlineCode\",{parentName:\"p\"},\"Firestore\"),\" to fetch data: initializing the database, connecting to it, etc. is what I would regard as being the core of the application. The way the database will be used is completely independent.\"),mdx(\"p\",null,\"By following a core/domain approach, you \",mdx(\"strong\",{parentName:\"p\"},\"will also increase the reusability of your utilities and make it pretty easy to reuse across projects\"),\".\"),mdx(\"h3\",null,\"Lib\"),mdx(\"p\",null,\"I have to be honest: I do not know why I'm calling this \",mdx(\"inlineCode\",{parentName:\"p\"},\"lib.\"),\" In Angular-land, it would be \",mdx(\"inlineCode\",{parentName:\"p\"},\"modules.\")),mdx(\"p\",null,\"But every codebase I've seen had \",mdx(\"inlineCode\",{parentName:\"p\"},\"lib\"),\" for business-logic code. So I stuck with it. As I said, familiarity is essential.\"),mdx(\"p\",null,\"What should we add to this library? Anything about the domain that isn't a component, like:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"queries\"),mdx(\"li\",{parentName:\"ul\"},\"mutations\"),mdx(\"li\",{parentName:\"ul\"},\"custom hooks\"),mdx(\"li\",{parentName:\"ul\"},\"contexts\"),mdx(\"li\",{parentName:\"ul\"},\"props functions (getServerSideProps, getInitialProps)\")),mdx(\"p\",null,\"These utilities are normally used within \",mdx(\"inlineCode\",{parentName:\"p\"},\"Components\"),\" (for the most part) and partly within the pages for functions such as \",mdx(\"inlineCode\",{parentName:\"p\"},\"getServerSideProps\"),\".\"),mdx(\"p\",null,\"For example, \",mdx(\"inlineCode\",{parentName:\"p\"},\"lib\"),\" could expose the props \",mdx(\"inlineCode\",{parentName:\"p\"},\"user/with-user-props.ts\"),\" which is a function returning the current session to the page where it's used.\"),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"lib\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"components\"),\" folders can be further splitted by \",mdx(\"inlineCode\",{parentName:\"p\"},\"entities\"),\". \"),mdx(\"p\",null,\"We could develop our folder structure in this way:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),`- src\n  - lib\n    - events\n      - hooks\n      - queries\n      - mutations\n      - utils\n      - server\n      - ...\n    - places\n      - hooks\n      - queries\n      - ...\n\n  - components\n    - events\n      - CreateEventForm.tsx\n      - EventsActionsDropdown.tsx\n    - places\n      - EditPlaceForm.tsx`))),mdx(\"h3\",null,\"Components\"),mdx(\"p\",null,\"This folder is, logically, on the same layer as \",mdx(\"inlineCode\",{parentName:\"p\"},\"lib\"),\". The reason why I do not place them in the same folder is to avoid excessive nesting, which can become nasty. \"),mdx(\"p\",null,\"As you may have imagined, here we can place the components that make up our pages. These are components that are highly tied to the domain, and are not supposed to be \",mdx(\"em\",{parentName:\"p\"},\"that\"),\" reusable across projects. \"),mdx(\"p\",null,\"They're business-logic rich, and are built using the UI components from \",mdx(\"inlineCode\",{parentName:\"p\"},\"core\"),\".\"),mdx(\"p\",null,\"The business-logic side of things, such as queries, or functions that mutate data, are all imported from \",mdx(\"inlineCode\",{parentName:\"p\"},\"lib\"),\", so that they can be reusable across components.\"),mdx(\"p\",null,\"For example, the component \",mdx(\"inlineCode\",{parentName:\"p\"},\"CreateEventForm\"),\" know about the domain, and uses a \",mdx(\"inlineCode\",{parentName:\"p\"},\"mutation\"),\" to create an event. This is all domain-dependent, and as such will be placed within \",mdx(\"inlineCode\",{parentName:\"p\"},\"components\"),\", rather than \",mdx(\"inlineCode\",{parentName:\"p\"},\"core\"),\".\"),mdx(\"h3\",null,\"Pages\"),mdx(\"p\",null,\"If you know Next, you may not need an explanation for this. This is a Next.js specific folder where we place our routes/pages. \"),mdx(\"p\",null,\"Next.js's router is file-system based: so, yes, no configurations. It's all driven by how we structure the pages in this folder.\"),mdx(\"p\",null,\"Of course, this is highly dependent on the domain of your application.\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),`- pages\n  - api\n    - events\n      - [event].tsx // will import from lib/server/events\n  - events\n    - [event].tsx // will import from lib/events and components/events`))),mdx(\"h2\",null,\"Imports between Layers\"),mdx(\"p\",null,\"Something important to clarify is the rules I have in place around importing between layers. \"),mdx(\"p\",null,\"Normally, an inner layer cannot import from an outer layer: that means that \",mdx(\"inlineCode\",{parentName:\"p\"},\"core\"),\" cannot impor from \",mdx(\"inlineCode\",{parentName:\"p\"},\"lib\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"components\"),\" and the latter cannot import from \",mdx(\"inlineCode\",{parentName:\"p\"},\"pages\"),\".\"),mdx(Image,{\"data-shadowless\":!0,src:\"/assets/images/posts/next-structure-imports-wrong.png\",mdxType:\"Image\"}),mdx(Image,{\"data-shadowless\":!0,src:\"/assets/images/posts/next-structure-imports.png\",mdxType:\"Image\"}),mdx(\"p\",null,\"This will ensure your \",mdx(\"inlineCode\",{parentName:\"p\"},\"core\"),\" is clearly decoupled from the domain, to avoid cyclical dependencies, and to keep your architecture untangled. I know first-hand how messy it can get when your imports have no rules at all.\"),mdx(\"h3\",null,\"Linting import paths with EsLint\"),mdx(\"p\",null,\"That's cool. But how can we make sure that we're using the rules above correctly when importing files in our application?\"),mdx(\"p\",null,\"EsLint can help us by adding a rule to lint our imports. \"),mdx(\"p\",null,\"By adding the following configuration to yours, you will be automatically warned when you're importing from the wrong paths:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-json\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"rules\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n  `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"import/no-restricted-paths\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"[\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"error\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n      `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"zones\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"[\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n          `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"target\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"./src/core\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n          `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"from\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"./src/components\"'),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n          `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"target\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"./src/core\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n          `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"from\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"./src/lib\"'),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n          `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"target\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"./src/core\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n          `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"from\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"./src/pages\"'),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n          `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"target\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"./src/lib\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n          `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"from\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"./src/pages\"'),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n          `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"target\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"./src/components\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n          `,mdx(\"span\",e({parentName:\"code\"},{className:\"token property\"}),'\"from\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"./src/pages\"'),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n      `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"]\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n  `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"]\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`))),mdx(\"p\",null,\"Assuming I was importing a page from \",mdx(\"inlineCode\",{parentName:\"p\"},\"pages\"),\" into any file within \",mdx(\"inlineCode\",{parentName:\"p\"},\"lib\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"components\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},\"core\"),\", I would see an error such as the below:\"),mdx(Image,{\"data-shadowless\":!0,src:\"/assets/images/posts/eslint-import-error-next.png\",mdxType:\"Image\"}),mdx(\"p\",null,\"If you find the rule too verbose, just replace \",mdx(\"inlineCode\",{parentName:\"p\"},\"error\"),\" with \",mdx(\"inlineCode\",{parentName:\"p\"},\"warning\"),\".\"),mdx(\"h2\",null,\"Final Words\"),mdx(\"p\",null,\"Whether you use this or another approach, remember that the important part of setting up a folder structure is that \",mdx(\"strong\",{parentName:\"p\"},\"it needs to work well for you and your use case\"),\": it shouldn't be a simple mess, nor should it be so complex you spend an hour to decide where to place a file. \"),mdx(\"p\",null,\"That's simply detrimental to your productivity, and it usually means you either have placed no rules at all, or your rules are way too strict.\"),mdx(\"p\",null,\"If you think this through with your team and agree a couple of rules, it will help with keeping the codebase familiar to everyone, avoid needless (but sometimes unavoidable) team arguments, and ultimately \",mdx(\"strong\",{parentName:\"p\"},\"keep you and the codebase as sane as possible\"),\".\"),mdx(\"h4\",null,\"Small, but ambitious apps\"),mdx(\"p\",null,\"This is my take: it's for small, but still ambitious apps. \"),mdx(\"p\",null,\"For larger, enterprise apps, I still think that a monorepo would be more beneficial (especially for teams who maintain more apps). \"),mdx(\"p\",null,\"But most apps aren't enteprise: if your goal is to get started with the right foot, ship quickly and well, give this a try.\"),mdx(\"p\",null,\"For any comment, or suggestions, please send me an email. Ciao!\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"series":[],"morePosts":[{"live":true,"readingTime":"3 min read","title":"Using Firestore's SDK in Next.js's SSR","date":"2021-11-27T16:30:30.000Z","slug":"using-firestore-sdk-in-next.js-ssr","collection":{"name":"Next","primaryColor":"#111","primaryColorLight":"#111111a6","contrastColor":"#ffffff","logo":"/assets/images/collections/next.webp","slug":"next"},"excerpt":"This blog post shows how you can work around a bug in React Firebase's library so that you can render components using Firestore on the server with Next.js"}],"moreArticles":[{"live":true,"readingTime":"3 min read","title":"Announcing MakerKit - A SaaS starter for Next.js and Firebase","date":"2021-12-17T23:00:00.000Z","slug":"announcing-makerkit-boilerplate-for-building-saas-with-next.js-firebase","coverImage":"/assets/images/posts/makerkit-post.webp","collection":{"name":"Next","primaryColor":"#111","primaryColorLight":"#111111a6","contrastColor":"#ffffff","logo":"/assets/images/collections/next.webp","slug":"next"},"excerpt":"MakerKit is a SaaS starter for Next.js, Firebase, and Tailwind CSS. It comes with authentication, organizations, payments with Stripe, a blog and documentation generators, and much more.","tags":["react","typescript","next","firebase"]},{"live":true,"readingTime":"8 min read","title":"Generating automatic banners for your Blog","date":"2021-12-03T00:00:00.322Z","slug":"automatic-banners-for-your-blog","collection":{"name":"Next","primaryColor":"#111","primaryColorLight":"#111111a6","contrastColor":"#ffffff","logo":"/assets/images/collections/next.webp","slug":"next"},"excerpt":"Say no to custom banners. This post will teach you how to generate automatic banners for your articles using Next.js, SVG and Sharp","tags":["next","react"]}],"type":1},"__N_SSG":true}