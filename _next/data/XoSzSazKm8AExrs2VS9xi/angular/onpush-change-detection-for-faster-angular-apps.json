{"pageProps":{"post":{"live":true,"readingTime":"5 min read","title":"OnPush change detection for faster Angular apps","date":"2019-04-15T00:00:00.322Z","slug":"onpush-change-detection-for-faster-angular-apps","coverImage":"/assets/images/posts/angular-logo.png","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Increasing your application's performance using OnPush change detection","content":"\nWhile not the fastest, by default Angular is one of the most performant frameworks around.\n\nEven if the majority of applications will run just fine without having to make any advanced optimizations, running complex applications even on older browsers and slower devices can still be a daunting task.\n\n## ChangeDetectionStrategy ðŸ”¥\n\nThe first and probably most important tweak we can do is changing the detection strategy Angular uses by default in order to minimize the amount of times the change detection will run, which will as a result make your app perform smoother and faster.\n\nBy default, you guessed it, Angular uses the strategy `ChangeDetectionStrategy.Default`. This means that the component will be always checked. Not efficient, right?\n\nWhy do that, if most components did not need to get updated? Enter `ChangeDetectionStrategy.OnPush`, which will instruct the change detection to skip a component except when any of the following situations happens:\n\n-   Input reference of the component changes\n-   DOM Event within a component has been dispatched (ex. click)\n-   Emission of an observable event subscribed with Async pipe\n-   change detection is manually run\n\nThis practice is even more important for large and complex applications as the amount of components skipped by the change detection is substantial. A simple way to see the differences between the two approaches is to use Chrome's rendering dev tools. Check the \"Paint flashing\" option and see for yourself how many times your components are needlessly re-rendered.\n\nIn the following example, our component will _not_ be updating the view:\n\n```typescript\n@Component({\n  ...,\n  template: '{{ count }}',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ChangeDetectionComponent implements OnInit {\n  count = 0;\n\n  ngOnInit() {\n    setInterval(() => ++this.count, 1000);\n  }\n}\n```\n\n### RxJS to the rescue\n\nDevelopers coming from Angular 1.x may finding this confusing and difficult to use: admittedly, using OnPush without RxJS is not always easy.\n\nWith that said, I like to argue that using OnPush offers a way for better coding practices. For example, by promoting the usage of RxJS and the `async` pipe, we get a predictable and declarative codebase which also happens to be super-performant.\n\nHere are some advantages to using the `async` pipe:\n\n-   automatically subscribes to observables\n-   automatically unsubscribes when the component gets destroyed\n-   effortless cooperation with ChangeStrategyStrategy.OnPush\n-   reduced LOC in our components\n\nIn short, RxJS + OnPush = win-win.\n\nLet's refactor the previous example using an `Observable`:\n\n```typescript\n@Component({\n  ...,\n  template: '{{ count$ | async }}',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ChangeDetectionComponent implements OnInit {\n  count$: Observable<number>;\n\n  ngOnInit() {\n    this.count$ = interval(1000)\n        .pipe(\n            map((count: number) => ++count)\n        );\n  }\n}\n```\n\nWe now have an elegant, declarative and performant solution!\n\n### NGRX\n\nWhen dealing with a large-scale application, I would suggest to use a state-management library. Not only because it helps manage state, but also because Angular state management libraries treat Observables as first-class citizens, just like the framework does. While there's a bunch of great libraries out there, I highly recommend NGRX.\n\nNGRX makes working with pure Angular components effortlessly by using RxJS for pulling data from the store, which means all the data held in components are observables.\n\nIf you don't know NGRX yet, then you should probably you give it a read.\n\nIn order to read the following example, all you need to know is that we're retrieveing data from the store (think of it as our database) as an observable, and that we're displaying it in our template by subscribing via the `async` pipe.\n\n```typescript\n@Component({\n    ...,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: `\n        <div *ngFor=\"let todo of (todos$ | async)\">\n            {{ todo.name }}\n        </div>\n    `\n})\nexport class TodosComponent {\n    constructor(private store: Store<AppState>) {}\n\n    ngOnInit() {\n        this.todos$ = this.store.select((state) => state.todos);\n    }\n}\n```\n\nThe framework will render the template every time `todos$` emits a new value.\n\n### When does not _not_ make sense to use OnPush?\n\nNever! OnPush is a simple way for making your applications _way_ faster, and personally see no reasons for not using it every time.\n\n## Refactoring a codebase for performance ðŸš€\n\nMost legacy Angular codebases I worked with were all using the default change detection, and the performance of the application was highly affected by that. Most developers were also not keen on the idea of using it, simply because it seems intimidating at first. But, well, it doesn't have to be.\n\nThe first thing to know if you are planning on refactoring a codebase by also using the OnPush change detection, is that you never start from the parent components. The reason is, when changeDetection is added to a parent component, as a result all its components tree will be affected.\n\nMy recommendation is to start from the leaves and working your way up to the parent components. Dumb components, if written well, shouldn't normally be affected because they simply receive inputs and render it, so they're the first you should be refactoring.\nOnce all the tree of a container has been refactored, it's time for the container.\n\nWhat's the container responsible for?\n\n-   Retreieving the data and passing it down to other components\n-   Putting together the layout of 1 or more components\n\nManaging the data is arguably the most difficult task front-end developers face today, which is why well-designed containers are key to the overall architecture of a project.\n\nI recommend two alternatives:\n\n-   use your own RxJS state management by using Subjects within services, and exposing data via Observables, if you don't feel like using third parties\n-   Use NGRX, NGXS, Akita, etc.?\n\n## Takeaways\n\n-   Use `OnPush` change detection strategy, your app will be faster\n-   Use `async` pipe, it will make `OnPush` easier to work with\n-   Use a state management library, alternatively leverage RxJS within your services\n-   Refactoring is hard(ish): start from your leaves components and work your way up until all components use `OnPush`\n","tags":["angular","performance"]},"content":{"compiledSource":"var l=Object.defineProperty,u=Object.defineProperties;var N=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var p=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable;var r=(a,n,t)=>n in a?l(a,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[n]=t,e=(a,n)=>{for(var t in n||(n={}))p.call(n,t)&&r(a,t,n[t]);if(o)for(var t of o(n))c.call(n,t)&&r(a,t,n[t]);return a},i=(a,n)=>u(a,N(n));var m=(a,n)=>{var t={};for(var s in a)p.call(a,s)&&n.indexOf(s)<0&&(t[s]=a[s]);if(a!=null&&o)for(var s of o(a))n.indexOf(s)<0&&c.call(a,s)&&(t[s]=a[s]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var s=t,{components:a}=s,n=m(s,[\"components\"]);return mdx(MDXLayout,i(e(e({},layoutProps),n),{components:a,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"While not the fastest, by default Angular is one of the most performant frameworks around.\"),mdx(\"p\",null,\"Even if the majority of applications will run just fine without having to make any advanced optimizations, running complex applications even on older browsers and slower devices can still be a daunting task.\"),mdx(\"h2\",null,\"ChangeDetectionStrategy \\u{1F525}\"),mdx(\"p\",null,\"The first and probably most important tweak we can do is changing the detection strategy Angular uses by default in order to minimize the amount of times the change detection will run, which will as a result make your app perform smoother and faster.\"),mdx(\"p\",null,\"By default, you guessed it, Angular uses the strategy \",mdx(\"inlineCode\",{parentName:\"p\"},\"ChangeDetectionStrategy.Default\"),\". This means that the component will be always checked. Not efficient, right?\"),mdx(\"p\",null,\"Why do that, if most components did not need to get updated? Enter \",mdx(\"inlineCode\",{parentName:\"p\"},\"ChangeDetectionStrategy.OnPush\"),\", which will instruct the change detection to skip a component except when any of the following situations happens:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Input reference of the component changes\"),mdx(\"li\",{parentName:\"ul\"},\"DOM Event within a component has been dispatched (ex. click)\"),mdx(\"li\",{parentName:\"ul\"},\"Emission of an observable event subscribed with Async pipe\"),mdx(\"li\",{parentName:\"ul\"},\"change detection is manually run\")),mdx(\"p\",null,`This practice is even more important for large and complex applications as the amount of components skipped by the change detection is substantial. A simple way to see the differences between the two approaches is to use Chrome's rendering dev tools. Check the \"Paint flashing\" option and see for yourself how many times your components are needlessly re-rendered.`),mdx(\"p\",null,\"In the following example, our component will \",mdx(\"em\",{parentName:\"p\"},\"not\"),\" be updating the view:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token decorator\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token at operator\"}),\"@\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token function\"}),\"Component\")),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n  `,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"...\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n  template`,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),\"'{{ count }}'\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n  changeDetection`,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" ChangeDetectionStrategy\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),`OnPush\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"export\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"class\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token class-name\"}),\"ChangeDetectionComponent\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"implements\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token class-name\"}),\"OnInit\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n  count `,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"0\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n  `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"ngOnInit\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"setInterval\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=>\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"++\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"this\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"count\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"1000\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n  `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`))),mdx(\"h3\",null,\"RxJS to the rescue\"),mdx(\"p\",null,\"Developers coming from Angular 1.x may finding this confusing and difficult to use: admittedly, using OnPush without RxJS is not always easy.\"),mdx(\"p\",null,\"With that said, I like to argue that using OnPush offers a way for better coding practices. For example, by promoting the usage of RxJS and the \",mdx(\"inlineCode\",{parentName:\"p\"},\"async\"),\" pipe, we get a predictable and declarative codebase which also happens to be super-performant.\"),mdx(\"p\",null,\"Here are some advantages to using the \",mdx(\"inlineCode\",{parentName:\"p\"},\"async\"),\" pipe:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"automatically subscribes to observables\"),mdx(\"li\",{parentName:\"ul\"},\"automatically unsubscribes when the component gets destroyed\"),mdx(\"li\",{parentName:\"ul\"},\"effortless cooperation with ChangeStrategyStrategy.OnPush\"),mdx(\"li\",{parentName:\"ul\"},\"reduced LOC in our components\")),mdx(\"p\",null,\"In short, RxJS + OnPush = win-win.\"),mdx(\"p\",null,\"Let's refactor the previous example using an \",mdx(\"inlineCode\",{parentName:\"p\"},\"Observable\"),\":\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token decorator\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token at operator\"}),\"@\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token function\"}),\"Component\")),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n  `,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"...\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n  template`,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),\"'{{ count$ | async }}'\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n  changeDetection`,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" ChangeDetectionStrategy\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),`OnPush\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"export\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"class\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token class-name\"}),\"ChangeDetectionComponent\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"implements\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token class-name\"}),\"OnInit\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n  count$`,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" Observable\",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token builtin\"}),\"number\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\">\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n  `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"ngOnInit\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"this\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"count$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"interval\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"1000\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"pipe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),`\n            `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"map\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"count\",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token builtin\"}),\"number\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=>\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"++\"),\"count\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n  `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`))),mdx(\"p\",null,\"We now have an elegant, declarative and performant solution!\"),mdx(\"h3\",null,\"NGRX\"),mdx(\"p\",null,\"When dealing with a large-scale application, I would suggest to use a state-management library. Not only because it helps manage state, but also because Angular state management libraries treat Observables as first-class citizens, just like the framework does. While there's a bunch of great libraries out there, I highly recommend NGRX.\"),mdx(\"p\",null,\"NGRX makes working with pure Angular components effortlessly by using RxJS for pulling data from the store, which means all the data held in components are observables.\"),mdx(\"p\",null,\"If you don't know NGRX yet, then you should probably you give it a read.\"),mdx(\"p\",null,\"In order to read the following example, all you need to know is that we're retrieveing data from the store (think of it as our database) as an observable, and that we're displaying it in our template by subscribing via the \",mdx(\"inlineCode\",{parentName:\"p\"},\"async\"),\" pipe.\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token decorator\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token at operator\"}),\"@\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token function\"}),\"Component\")),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"...\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n    changeDetection`,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" ChangeDetectionStrategy\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"OnPush\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n    template`,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token template-string\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token template-punctuation string\"}),\"`\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token string\"})),`\n`,mdx(\"span\",e({parentName:\"span\"},{className:\"token string\"}),'        <div *ngFor=\"let todo of (todos$ | async)\">'),`\n`,mdx(\"span\",e({parentName:\"span\"},{className:\"token string\"}),\"            {{ todo.name }}\"),`\n`,mdx(\"span\",e({parentName:\"span\"},{className:\"token string\"}),\"        </div>\"),`\n`,mdx(\"span\",e({parentName:\"span\"},{className:\"token string\"}),\"    \"),mdx(\"span\",e({parentName:\"span\"},{className:\"token template-punctuation string\"}),\"`\")),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"export\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"class\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token class-name\"}),\"TodosComponent\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"constructor\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"private\"),\" store\",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" Store\",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<\"),\"AppState\",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\">\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"ngOnInit\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"this\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"todos$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"this\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"store\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"select\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"state\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=>\"),\" state\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"todos\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`))),mdx(\"p\",null,\"The framework will render the template every time \",mdx(\"inlineCode\",{parentName:\"p\"},\"todos$\"),\" emits a new value.\"),mdx(\"h3\",null,\"When does not \",mdx(\"em\",{parentName:\"h3\"},\"not\"),\" make sense to use OnPush?\"),mdx(\"p\",null,\"Never! OnPush is a simple way for making your applications \",mdx(\"em\",{parentName:\"p\"},\"way\"),\" faster, and personally see no reasons for not using it every time.\"),mdx(\"h2\",null,\"Refactoring a codebase for performance \\u{1F680}\"),mdx(\"p\",null,\"Most legacy Angular codebases I worked with were all using the default change detection, and the performance of the application was highly affected by that. Most developers were also not keen on the idea of using it, simply because it seems intimidating at first. But, well, it doesn't have to be.\"),mdx(\"p\",null,\"The first thing to know if you are planning on refactoring a codebase by also using the OnPush change detection, is that you never start from the parent components. The reason is, when changeDetection is added to a parent component, as a result all its components tree will be affected.\"),mdx(\"p\",null,`My recommendation is to start from the leaves and working your way up to the parent components. Dumb components, if written well, shouldn't normally be affected because they simply receive inputs and render it, so they're the first you should be refactoring.\nOnce all the tree of a container has been refactored, it's time for the container.`),mdx(\"p\",null,\"What's the container responsible for?\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Retreieving the data and passing it down to other components\"),mdx(\"li\",{parentName:\"ul\"},\"Putting together the layout of 1 or more components\")),mdx(\"p\",null,\"Managing the data is arguably the most difficult task front-end developers face today, which is why well-designed containers are key to the overall architecture of a project.\"),mdx(\"p\",null,\"I recommend two alternatives:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"use your own RxJS state management by using Subjects within services, and exposing data via Observables, if you don't feel like using third parties\"),mdx(\"li\",{parentName:\"ul\"},\"Use NGRX, NGXS, Akita, etc.?\")),mdx(\"h2\",null,\"Takeaways\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Use \",mdx(\"inlineCode\",{parentName:\"li\"},\"OnPush\"),\" change detection strategy, your app will be faster\"),mdx(\"li\",{parentName:\"ul\"},\"Use \",mdx(\"inlineCode\",{parentName:\"li\"},\"async\"),\" pipe, it will make \",mdx(\"inlineCode\",{parentName:\"li\"},\"OnPush\"),\" easier to work with\"),mdx(\"li\",{parentName:\"ul\"},\"Use a state management library, alternatively leverage RxJS within your services\"),mdx(\"li\",{parentName:\"ul\"},\"Refactoring is hard(ish): start from your leaves components and work your way up until all components use \",mdx(\"inlineCode\",{parentName:\"li\"},\"OnPush\"))))}MDXContent.isMDXComponent=!0;\n","scope":{}},"series":[],"morePosts":[],"moreArticles":[{"live":true,"readingTime":"2 min read","title":"Benchmarking Angular 12 with Webpack 5","date":"2021-05-14T00:00:00.322Z","slug":"webpack-5-angular12","coverImage":"/assets/images/posts/benchmarking-webpack-5.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Angular 12 has been released and with it the much awaited Webpack 5 upgrade. In this post I benchmarked the bundle-size and compilation speed against the previous version","tags":["angular"]},{"live":true,"readingTime":"5 min read","title":"Principles for creating libraries with Nx and Angular","date":"2021-02-07T00:00:00.322Z","slug":"how-to-organize-nx-modules-with-angular","coverImage":"/assets/images/posts/organize-nx-modules-ngrx.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Working with Nx may be confusing. This article explains how I create Nx libraries and the principles behind my motivations","tags":["nx","angular"]},{"live":true,"readingTime":"3 min read","title":"Where to put your Angular models?","date":"2020-08-03T00:00:00.322Z","slug":"angular-where-to-put-models","ogImage":{"url":"/assets/images/posts/where-put-angular-models.png"},"coverImage":"/assets/images/posts/where-put-angular-models.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Organizing entities and models in your Angular app may be hard. This article explains where to put your entities and what mistakes to watch out for","tags":["angular","architecture"]},{"live":true,"readingTime":"5 min read","title":"Using the Intersection Observer API with Angular","date":"2020-08-01T00:00:00.322Z","slug":"intersection-observer-with-angular","coverImage":"/assets/images/posts/intersection-observer.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"This article shows how to build a directive with Angular that uses the Intersection Observer API to check when an element becomes visible on the page","tags":["angular","performance"]},{"live":true,"readingTime":"3 min read","title":"Setters vs ngOnChanges: which one is better?","date":"2020-07-30T00:00:00.322Z","slug":"setters-vs-ng-on-changes","coverImage":"/assets/images/posts/setters-vs-on-changes.webp","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Listening to Input changes can be done in different ways. But which one should you use?","tags":["angular"]},{"live":true,"readingTime":"3 min read","title":"Async Rendering with a single Rx Operator","date":"2020-07-11T00:00:00.322Z","slug":"async-rendering-with-a-single-rx-operator","collection":{"name":"Angular","primaryColor":"#e23236","primaryColorLight":"#dd00316e","contrastColor":"#ffffff","logo":"/assets/images/collections/angular.webp"},"excerpt":"Increase your app rendering performance with this simple Rx operator","tags":["angular","rxjs"]}],"type":1},"__N_SSG":true}