{"pageProps":{"post":{"live":true,"readingTime":"9 min read","title":"RxJS Patterns: Efficiency and Performance","date":"2019-09-16T00:00:00.000Z","slug":"rxjs-patterns-efficiency-and-performance","coverImage":"https://cdn-images-1.medium.com/max/8120/0*s2vR3V3jI171miko","collection":{"name":"RxJs","primaryColor":"#d81b60","primaryColorLight":"#d81b6085","contrastColor":"#fff","logo":"/assets/images/collections/rxjs.webp"},"excerpt":"A rundown of all RxJS operators and techniques you can leverage to avoid needless computation and make your code snappier and faster","content":"\nThis post was originally published, by myself, on the [Bit](https://blog.bitsrc.io) blog\n\nRxJS is a library that helps make it easier to compose asynchronous or callback-based code, as described on its [home page](https://rxjs.dev/).\n\nBut did you know that RxJS could also help to make your applications **more efficient and performant **thanks to its powerful operators?\n\nIn this article, I want to share the most useful operators and techniques that help avoid unnecessary and repeated computations that in turn will make your app faster and more efficient, and all we need is some RxJS magic.\n\n**Notice**: the examples below are simplified and may not be complete snippets.\n\n## Filtering\n\nFiltering operators allow us to filter events from the stream that we want to disregard and avoid sending them to the observable’s subscribers. If we filter the events soon enough in the pipeline, we avoid passing them down to other operators and to the subscription callback.\n\nOf course, this is especially important if the pipeline is doing heavy-computations or HTTP requests.\n\nThese operators are primarily used for logic rather than performance reasons, although they’re still useful to avoid computing needless tasks.\n\nThe questions you can ask yourself when writing a stream is: should I pass all items through or can I skip them at some point in the pipeline?\n\n### filter\n\nThe simplest operator to avoid needless computation (among other things) is filter.\n\nIf you are already familiar with the method Array.prototype.filter, then you’ll probably know its usage already: we pass a predicate as a parameter to the operator, and if it returns true for the event being streamed, the event will be passed through the pipeline, otherwise, it will be discarded.\n\n\n```typescript\nconst numbers$ = of(1, 2, 3, 4, 5);\nconst predicate = (n) => n <= 2;\n\nnumbers$\n    .pipe(\n        filter(predicate)\n    )\n    .subscribe(console.log);\n// will log 1,2\n```\n\n### distinctUntilChanged\n\nAnother type of filtering operator is distinctUntilChanged.\n\nThis operator will compare the current value with the previous value of the source Observable, and if these are different, it will then pass the item through. In short, it works just like filter, but will compare the previous and the current value.\n\nA very common scenario that we can use in order to explain how this operator works is receiving inputs from a text-input and skip all the events whose value is unchanged from the previous.\n\n\n```typescript\nconst textChanges$ = fromEvent(textElement, 'input');\n\ntextChanges$\n    .pipe(\n        filter(Boolean),\n        distinctUntilChanged()\n    )\n    .subscribe(console.log);\n```\n\nBut this only works for primitive values. If you want to pass a more powerful equality predicate, then you can supply a function and compare manually the previous and current values.\n\n```typescript\nconst stream$ = /* some Rx stream with objects */\nconst isEqual = require('lodash/isEqual');\n\nstream$\n    .pipe(\n        distinctUntilChanged(isEqual)\n    )\n    .subscribe(/**/);\n```\n\n## Debouncing and Throttling\n\nDebouncing and throttling are techniques used to batch events emitted within a time window in a single emission.\n\nThese two techniques are sometimes used and referred to interchangeably even though they achieve similar things in different ways.\n\n### throttleTime\n\nThe operators throttleTime is used to only emit the first item received within the time window specified in milliseconds, then wait again for the entire amount of the time window before a subsequent event can be emitted.\n\n```typescript\nconst textChanges$ = fromEvent(textElement, 'input');\n\ntextChanges$\n    .pipe(\n        filter(Boolean),\n        distinctUntilChanged(),\n        throttleTime(1000)\n    )\n    .subscribe(console.log);\n```\n\nLet’s explain this with a simple visual representation:\n\n```\ntime in ms : 0---500---1000---1500---2000\nevents     : _a_____b__________c__d___e__\n```\n\nWhich events emitted? a and c! The first event a was collected within the time frame 0 and 1000, the second event b was skipped as it got emitted within the window. Then c emitted, and d and e were filtered.\n\n### debounceTime\n\nContrary to throttleTime, the operator debounceTime is used to only emit the latest item received within the time window specified in milliseconds. Just like throttling, debouncing will wait for the time windows before a new event can be emitted.\n\n```typescript\nconst textChanges$ = fromEvent(textElement, 'input');\n\ntextChanges$\n    .pipe(\n        filter(Boolean),\n        distinctUntilChanged(),\n        debounceTime(1000)\n    )\n    .subscribe(console.log);\n\n```\n\nLet’s repeat the same representation used with throttleTime to understand the difference:\n\n```\ntime in ms : 0---500---1000---1500---2000\nevents     : _a_____b__________c__d___e__\n```\n\nIn this scenario, only b and e emitted.\n\n### How do throttling and debouncing help?\n\nThese operators are used to delay and batch the execution of repeated events within a time frame.\n\nThey help in various situations where we want to avoid useless execution of commands or expensive operations like HTTP requests.\n\nImagine user-input changes that trigger requests to a server for each change: if we didn’t debounce it, we would not only spam our service but also degrade the UX for our users. In my experience, debouncing every 250 to 500 ms is the sweet spot to ensure smooth user experience.\n\n## Canceling\n\nCanceling subscriptions is an important and too often neglected task that I see very often when reviewing PRs.\n\nCanceling is not only important to reduce useless computations and avoid memory leaks, but also, more importantly, to prevent possible bugs in our applications.\n\n### Unsubscribing\n\nThe easiest, imperative way to cancel subscriptions is to simply call the unsubscribe method that every subscription object should have implemented.\n\n```typescript\nconst inputs$ = fromEvent(element, 'input');\nconst subscription = inputs.subscribe(/*some work*/);\n\nsubscription.unsubscribe();\n```\n\nWhile this is a totally effective and working example for unsubscribing streams, it is usually not considered a best-practice. In fact, Rx provides powerful operators that can help us achieve the same, but in a more declarative and reactive way.\n\n### takeUntil\n\nMy favorite way of unsubscribing from streams is takeUntil. This operator will allow you to unsubscribe a stream when the stream passed as input to the operator emits an event. Oh, that seems too complicated, but it’s actually not.\n\nLet’s see an example:\n\n* we have two observables that emit with an interval of respectively 1000 ms (1 second) and 100 ms\n\n* the stream that emits every 100ms will unsubscribe when the other stream emits, which will happen every 1 second\n\n```typescript\n// emit every 1 second\nconst slow$ = interval(1000);\n\n// emit every 100 ms\nconst fast$ = interval(100).pipe(\n    takeUntil(slow$)\n);\n\nfast$.subscribe({\n    next(n) {\n        console.log(n);\n    },\n    complete() {\n        console.log('I am unsubscribed!');\n    }\n});\n\nslow$.subscribe();\n```\n\nWhich will produce the following output:\n\n```\n0\n1\n2\n3\n4\n5\n6\n7\n8\nI am unsubscribed!\n```\n\n### takeWhile\n\nThis operator is very useful to unsubscribe streams based on their own value. One of the ways I needed to use this operator is to stop certain timers once they reach a certain number of iterations. For instance, a countdown timer.\n\nIn the following example, I want to stop a timer once it iterates for 5 times. —\n\n* the takeWhile operator accepts a predicate function whose parameter is the current value of the stream\n\n* if the predicate is truthy, it will keep emitting values; if it’s falsy, then it will unsubscribe the stream\n\n```typescript\nconst stream$ = interval(1000).pipe(\n    takeWhile(n => n < 5)\n);\n\nstream$.subscribe({\n    next(n) {\n        console.log(n)\n    },\n    complete() {\n        console.log('I am unsubscribed!')\n    }\n});\n```\n\nWhich will produce the following output:\n\n```\n0\n1\n2\n3\n4\nI am unsubscribed!\n```\n\n### switchMap\n\nThe operator switchMap is commonly used for flattening a stream of observables.\n\nWhat you may know, is that it has a peculiar behavior: on each emission, instead of maintaining more than one inner observables, it will complete the previous inner observable and then emit the new one.\n\nThat is, if we have an in-flight HTTP request, it will be canceled when another emission takes place. Of course, depending on the observable type you use, you’d have different teardown effects.\n\nIn the example below, I created a simple snippet that will issue requests when the user inputs values in a form. The request will query Github’s API for repositories and render them on screen.\n\nAt the end of the article, we will revisit this example by adding a powerful caching mechanism, and the link to the code.\n\n## Batching\n\nIn situations where you repeatedly perform a very expensive operation within a very small time frame, such as re-rendering a DOM tree on updates from a stream, batching can help collect updates and render them at once.\n\nThe first time I employed this technique was when working with Angular.js: on every update from the back-end, the digest cycle was called so many times it was clocking up the application.\n\nThat’s when I thought: why not batch the updates in an array, and then update only every 1 or 2 seconds? And in order to do this, we can use the buffer or bufferTime operators (or, the other operators in the buffering family).\n\n### bufferTime\n\nThe operator bufferTime is a shortcut for the operator buffer that accepts an amount of time in milliseconds and will batch the stream every n milliseconds in an array.\n\nFor example, in the following example we mock up a stream that emits every 500 milliseconds. The buffer will be set at 2 seconds. That means, we collect 4 updates within a 2-second window.\n\n```typescript\nthis.stream$ = interval(500);\n\nthis.data$ = this.stream$.pipe(\n    bufferTime(2000),\n    filter((items) => items.length > 0),\n    scan((acc, items) => {\n        return [...acc, ...items];\n    }, [])\n);\n\nthis.data$.subscribe((items) => {\n    /* expensive operation here */\n\n    console.log('re-render!');\n});\n```\n\nLet’s summarise the above:\n\n* we have a stream that emits events with data (in the example, it’s simply an interval with numbers)\n\n* we batch the events every 2 seconds with bufferTime(2000)\n\n* we filter all the events that are empty; in our example makes little sense as we always have values, but this is something you may want to do in a real application as sometimes you’ll be receiving data that doesn’t need to be re-rendered\n\n* we use the scan operator that works just like Array.prototype.reduce. We collect events and group them all in an array — in case we are working with a large list we want to re-render\n\nThere are two things to notice when using this technique:\n\n* test performance! buffering will keep working under the hood collecting events: only use this if rendering, or another expensive operation, is a real bottleneck in your application\n\n* because of the above, do remember to **unsubscribe** the stream when not needed\n\n## Caching\n\nEvery application needs some level of caching for improving efficiency and performance. One of the most common situations where caching is important is HTTP requests, and we can leverage RxJS to make this very easily.\n\nFor example, we may not only want to return the cached response, but we may also want to stop any in-flight requests that return the same values, assuming of course that the requests are idempotent.\n\nIn the below example, we will extend our repositories search application with a cache. The cache works in this way:\n\n* we create a Map to store the name and the result of the request\n\n* when we are about to issue the request, we check if we have a cached result. If not, we go on and execute the request\n\n* when the request is executed, we place the observable itself in a cache, and we use the operator shareReplay(1) to store in memory the latest 1 emissions. When the observable (in the cache) is subscribed again, it will yield its result rather than issue the request again\n\nThe example above is simplified and doesn’t take into account error-handling and such. As a result, if you use it as inspiration for your code, you may want to handle more situations.\n\nIf you want to see this in action, please visit the following [Stackblitz link](https://stackblitz.com/edit/switchmap-with-cache-example?file=index.ts).\n\n## Takeaways\n\nRxJS is an incredibly powerful tool. While its learning curve might be steep at first, learning how to use it is a great skill to add to your personal developer arsenal.\n\nWhile it can easily make your code more declarative and readable, it can also help us improve the efficiency and performance of our applications with just a few lines of code added to our streams.\n\nThe techniques above are an exhaustive, yet far from complete, list of techniques that use RxJS operators to make your code efficient and performant.\n","canonical":"https://blog.bitsrc.io/rxjs-patterns-efficiency-and-performance-10bbf272c3fc","tags":["rxjs","performance"]},"content":{"compiledSource":"var l=Object.defineProperty,u=Object.defineProperties;var N=Object.getOwnPropertyDescriptors;var p=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable;var r=(a,n,t)=>n in a?l(a,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[n]=t,e=(a,n)=>{for(var t in n||(n={}))o.call(n,t)&&r(a,t,n[t]);if(p)for(var t of p(n))c.call(n,t)&&r(a,t,n[t]);return a},i=(a,n)=>u(a,N(n));var m=(a,n)=>{var t={};for(var s in a)o.call(a,s)&&n.indexOf(s)<0&&(t[s]=a[s]);if(a!=null&&p)for(var s of p(a))n.indexOf(s)<0&&c.call(a,s)&&(t[s]=a[s]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var s=t,{components:a}=s,n=m(s,[\"components\"]);return mdx(MDXLayout,i(e(e({},layoutProps),n),{components:a,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"This post was originally published, by myself, on the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://blog.bitsrc.io\"}),\"Bit\"),\" blog\"),mdx(\"p\",null,\"RxJS is a library that helps make it easier to compose asynchronous or callback-based code, as described on its \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://rxjs.dev/\"}),\"home page\"),\".\"),mdx(\"p\",null,\"But did you know that RxJS could also help to make your applications \",mdx(\"strong\",{parentName:\"p\"},\"more efficient and performant \"),\"thanks to its powerful operators?\"),mdx(\"p\",null,\"In this article, I want to share the most useful operators and techniques that help avoid unnecessary and repeated computations that in turn will make your app faster and more efficient, and all we need is some RxJS magic.\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Notice\"),\": the examples below are simplified and may not be complete snippets.\"),mdx(\"h2\",null,\"Filtering\"),mdx(\"p\",null,\"Filtering operators allow us to filter events from the stream that we want to disregard and avoid sending them to the observable\\u2019s subscribers. If we filter the events soon enough in the pipeline, we avoid passing them down to other operators and to the subscription callback.\"),mdx(\"p\",null,\"Of course, this is especially important if the pipeline is doing heavy-computations or HTTP requests.\"),mdx(\"p\",null,\"These operators are primarily used for logic rather than performance reasons, although they\\u2019re still useful to avoid computing needless tasks.\"),mdx(\"p\",null,\"The questions you can ask yourself when writing a stream is: should I pass all items through or can I skip them at some point in the pipeline?\"),mdx(\"h3\",null,\"filter\"),mdx(\"p\",null,\"The simplest operator to avoid needless computation (among other things) is filter.\"),mdx(\"p\",null,\"If you are already familiar with the method Array.prototype.filter, then you\\u2019ll probably know its usage already: we pass a predicate as a parameter to the operator, and if it returns true for the event being streamed, the event will be passed through the pipeline, otherwise, it will be discarded.\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" numbers$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"of\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"1\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"2\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"3\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"4\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"5\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function-variable function\"}),\"predicate\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"n\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=>\"),\" n \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"2\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\nnumbers$\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"pipe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"filter\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"predicate\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"subscribe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token builtin\"}),\"console\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"log\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token comment\"}),\"// will log 1,2\"),`\n`))),mdx(\"h3\",null,\"distinctUntilChanged\"),mdx(\"p\",null,\"Another type of filtering operator is distinctUntilChanged.\"),mdx(\"p\",null,\"This operator will compare the current value with the previous value of the source Observable, and if these are different, it will then pass the item through. In short, it works just like filter, but will compare the previous and the current value.\"),mdx(\"p\",null,\"A very common scenario that we can use in order to explain how this operator works is receiving inputs from a text-input and skip all the events whose value is unchanged from the previous.\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" textChanges$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"fromEvent\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"textElement\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),\"'input'\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\ntextChanges$\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"pipe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"filter\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"Boolean\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"distinctUntilChanged\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"subscribe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token builtin\"}),\"console\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"log\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`))),mdx(\"p\",null,\"But this only works for primitive values. If you want to pass a more powerful equality predicate, then you can supply a function and compare manually the previous and current values.\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" stream$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token comment\"}),\"/* some Rx stream with objects */\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" isEqual \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"require\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),\"'lodash/isEqual'\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\nstream$\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"pipe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"distinctUntilChanged\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"isEqual\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"subscribe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token comment\"}),\"/**/\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`))),mdx(\"h2\",null,\"Debouncing and Throttling\"),mdx(\"p\",null,\"Debouncing and throttling are techniques used to batch events emitted within a time window in a single emission.\"),mdx(\"p\",null,\"These two techniques are sometimes used and referred to interchangeably even though they achieve similar things in different ways.\"),mdx(\"h3\",null,\"throttleTime\"),mdx(\"p\",null,\"The operators throttleTime is used to only emit the first item received within the time window specified in milliseconds, then wait again for the entire amount of the time window before a subsequent event can be emitted.\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" textChanges$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"fromEvent\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"textElement\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),\"'input'\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\ntextChanges$\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"pipe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"filter\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"Boolean\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"distinctUntilChanged\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"throttleTime\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"1000\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"subscribe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token builtin\"}),\"console\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"log\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`))),mdx(\"p\",null,\"Let\\u2019s explain this with a simple visual representation:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),`time in ms : 0---500---1000---1500---2000\nevents     : _a_____b__________c__d___e__`))),mdx(\"p\",null,\"Which events emitted? a and c! The first event a was collected within the time frame 0 and 1000, the second event b was skipped as it got emitted within the window. Then c emitted, and d and e were filtered.\"),mdx(\"h3\",null,\"debounceTime\"),mdx(\"p\",null,\"Contrary to throttleTime, the operator debounceTime is used to only emit the latest item received within the time window specified in milliseconds. Just like throttling, debouncing will wait for the time windows before a new event can be emitted.\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" textChanges$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"fromEvent\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"textElement\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),\"'input'\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\ntextChanges$\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"pipe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"filter\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"Boolean\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"distinctUntilChanged\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"debounceTime\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"1000\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"subscribe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token builtin\"}),\"console\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"log\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n`))),mdx(\"p\",null,\"Let\\u2019s repeat the same representation used with throttleTime to understand the difference:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),`time in ms : 0---500---1000---1500---2000\nevents     : _a_____b__________c__d___e__`))),mdx(\"p\",null,\"In this scenario, only b and e emitted.\"),mdx(\"h3\",null,\"How do throttling and debouncing help?\"),mdx(\"p\",null,\"These operators are used to delay and batch the execution of repeated events within a time frame.\"),mdx(\"p\",null,\"They help in various situations where we want to avoid useless execution of commands or expensive operations like HTTP requests.\"),mdx(\"p\",null,\"Imagine user-input changes that trigger requests to a server for each change: if we didn\\u2019t debounce it, we would not only spam our service but also degrade the UX for our users. In my experience, debouncing every 250 to 500 ms is the sweet spot to ensure smooth user experience.\"),mdx(\"h2\",null,\"Canceling\"),mdx(\"p\",null,\"Canceling subscriptions is an important and too often neglected task that I see very often when reviewing PRs.\"),mdx(\"p\",null,\"Canceling is not only important to reduce useless computations and avoid memory leaks, but also, more importantly, to prevent possible bugs in our applications.\"),mdx(\"h3\",null,\"Unsubscribing\"),mdx(\"p\",null,\"The easiest, imperative way to cancel subscriptions is to simply call the unsubscribe method that every subscription object should have implemented.\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" inputs$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"fromEvent\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"element\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),\"'input'\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" subscription \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" inputs\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"subscribe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token comment\"}),\"/*some work*/\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\nsubscription`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"unsubscribe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`))),mdx(\"p\",null,\"While this is a totally effective and working example for unsubscribing streams, it is usually not considered a best-practice. In fact, Rx provides powerful operators that can help us achieve the same, but in a more declarative and reactive way.\"),mdx(\"h3\",null,\"takeUntil\"),mdx(\"p\",null,\"My favorite way of unsubscribing from streams is takeUntil. This operator will allow you to unsubscribe a stream when the stream passed as input to the operator emits an event. Oh, that seems too complicated, but it\\u2019s actually not.\"),mdx(\"p\",null,\"Let\\u2019s see an example:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"we have two observables that emit with an interval of respectively 1000 ms (1 second) and 100 ms\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"the stream that emits every 100ms will unsubscribe when the other stream emits, which will happen every 1 second\"))),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token comment\"}),\"// emit every 1 second\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" slow$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"interval\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"1000\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token comment\"}),\"// emit every 100 ms\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" fast$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"interval\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"100\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"pipe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"takeUntil\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"slow$\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\nfast$`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"subscribe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"next\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"n\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token builtin\"}),\"console\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"log\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"n\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"complete\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token builtin\"}),\"console\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"log\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),\"'I am unsubscribed!'\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\nslow$`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"subscribe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`))),mdx(\"p\",null,\"Which will produce the following output:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),`0\n1\n2\n3\n4\n5\n6\n7\n8\nI am unsubscribed!`))),mdx(\"h3\",null,\"takeWhile\"),mdx(\"p\",null,\"This operator is very useful to unsubscribe streams based on their own value. One of the ways I needed to use this operator is to stop certain timers once they reach a certain number of iterations. For instance, a countdown timer.\"),mdx(\"p\",null,\"In the following example, I want to stop a timer once it iterates for 5 times. \\u2014\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"the takeWhile operator accepts a predicate function whose parameter is the current value of the stream\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"if the predicate is truthy, it will keep emitting values; if it\\u2019s falsy, then it will unsubscribe the stream\"))),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" stream$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"interval\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"1000\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"pipe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"takeWhile\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"n \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=>\"),\" n \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"5\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\nstream$`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"subscribe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"next\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"n\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token builtin\"}),\"console\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"log\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"n\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"complete\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token builtin\"}),\"console\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"log\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),\"'I am unsubscribed!'\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`))),mdx(\"p\",null,\"Which will produce the following output:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),`0\n1\n2\n3\n4\nI am unsubscribed!`))),mdx(\"h3\",null,\"switchMap\"),mdx(\"p\",null,\"The operator switchMap is commonly used for flattening a stream of observables.\"),mdx(\"p\",null,\"What you may know, is that it has a peculiar behavior: on each emission, instead of maintaining more than one inner observables, it will complete the previous inner observable and then emit the new one.\"),mdx(\"p\",null,\"That is, if we have an in-flight HTTP request, it will be canceled when another emission takes place. Of course, depending on the observable type you use, you\\u2019d have different teardown effects.\"),mdx(\"p\",null,\"In the example below, I created a simple snippet that will issue requests when the user inputs values in a form. The request will query Github\\u2019s API for repositories and render them on screen.\"),mdx(\"p\",null,\"At the end of the article, we will revisit this example by adding a powerful caching mechanism, and the link to the code.\"),mdx(\"h2\",null,\"Batching\"),mdx(\"p\",null,\"In situations where you repeatedly perform a very expensive operation within a very small time frame, such as re-rendering a DOM tree on updates from a stream, batching can help collect updates and render them at once.\"),mdx(\"p\",null,\"The first time I employed this technique was when working with Angular.js: on every update from the back-end, the digest cycle was called so many times it was clocking up the application.\"),mdx(\"p\",null,\"That\\u2019s when I thought: why not batch the updates in an array, and then update only every 1 or 2 seconds? And in order to do this, we can use the buffer or bufferTime operators (or, the other operators in the buffering family).\"),mdx(\"h3\",null,\"bufferTime\"),mdx(\"p\",null,\"The operator bufferTime is a shortcut for the operator buffer that accepts an amount of time in milliseconds and will batch the stream every n milliseconds in an array.\"),mdx(\"p\",null,\"For example, in the following example we mock up a stream that emits every 500 milliseconds. The buffer will be set at 2 seconds. That means, we collect 4 updates within a 2-second window.\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-typescript\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-typescript\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"this\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"stream$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"interval\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"500\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"this\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"data$ \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"this\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"stream$\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"pipe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"bufferTime\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"2000\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"filter\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"items\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=>\"),\" items\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"length \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\">\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token number\"}),\"0\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"scan\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"acc\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" items\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=>\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n        `,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"return\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"[\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"...\"),\"acc\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"...\"),\"items\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"]\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"[\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"]\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"this\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"data$\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"subscribe\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"items\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=>\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token comment\"}),\"/* expensive operation here */\"),`\n\n    `,mdx(\"span\",e({parentName:\"code\"},{className:\"token builtin\"}),\"console\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"log\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),\"'re-render!'\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`))),mdx(\"p\",null,\"Let\\u2019s summarise the above:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"we have a stream that emits events with data (in the example, it\\u2019s simply an interval with numbers)\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"we batch the events every 2 seconds with bufferTime(2000)\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"we filter all the events that are empty; in our example makes little sense as we always have values, but this is something you may want to do in a real application as sometimes you\\u2019ll be receiving data that doesn\\u2019t need to be re-rendered\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"we use the scan operator that works just like Array.prototype.reduce. We collect events and group them all in an array \\u2014 in case we are working with a large list we want to re-render\"))),mdx(\"p\",null,\"There are two things to notice when using this technique:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"test performance! buffering will keep working under the hood collecting events: only use this if rendering, or another expensive operation, is a real bottleneck in your application\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"because of the above, do remember to \",mdx(\"strong\",{parentName:\"p\"},\"unsubscribe\"),\" the stream when not needed\"))),mdx(\"h2\",null,\"Caching\"),mdx(\"p\",null,\"Every application needs some level of caching for improving efficiency and performance. One of the most common situations where caching is important is HTTP requests, and we can leverage RxJS to make this very easily.\"),mdx(\"p\",null,\"For example, we may not only want to return the cached response, but we may also want to stop any in-flight requests that return the same values, assuming of course that the requests are idempotent.\"),mdx(\"p\",null,\"In the below example, we will extend our repositories search application with a cache. The cache works in this way:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"we create a Map to store the name and the result of the request\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"when we are about to issue the request, we check if we have a cached result. If not, we go on and execute the request\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"when the request is executed, we place the observable itself in a cache, and we use the operator shareReplay(1) to store in memory the latest 1 emissions. When the observable (in the cache) is subscribed again, it will yield its result rather than issue the request again\"))),mdx(\"p\",null,\"The example above is simplified and doesn\\u2019t take into account error-handling and such. As a result, if you use it as inspiration for your code, you may want to handle more situations.\"),mdx(\"p\",null,\"If you want to see this in action, please visit the following \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://stackblitz.com/edit/switchmap-with-cache-example?file=index.ts\"}),\"Stackblitz link\"),\".\"),mdx(\"h2\",null,\"Takeaways\"),mdx(\"p\",null,\"RxJS is an incredibly powerful tool. While its learning curve might be steep at first, learning how to use it is a great skill to add to your personal developer arsenal.\"),mdx(\"p\",null,\"While it can easily make your code more declarative and readable, it can also help us improve the efficiency and performance of our applications with just a few lines of code added to our streams.\"),mdx(\"p\",null,\"The techniques above are an exhaustive, yet far from complete, list of techniques that use RxJS operators to make your code efficient and performant.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"series":[],"morePosts":[{"live":true,"readingTime":"2 min read","title":"Testing RxJS timers with Jest","date":"2021-11-11T21:49:22.000Z","slug":"testing-rxjs-timers-with-jest","collection":{"name":"RxJs","primaryColor":"#d81b60","primaryColorLight":"#d81b6085","contrastColor":"#fff","logo":"/assets/images/collections/rxjs.webp"}}],"moreArticles":[{"live":true,"readingTime":"5 min read","title":"A Reactive Enum with Typescript and RxJs","date":"2021-11-11T23:00:00.000Z","slug":"reactive-enum-typescript-rxjs","coverImage":"/assets/images/posts/reactive-enum-ts-rxjs.webp","collection":{"name":"RxJs","primaryColor":"#d81b60","primaryColorLight":"#d81b6085","contrastColor":"#fff","logo":"/assets/images/collections/rxjs.webp"},"excerpt":"Typescript's template literals' types allow us to generate dynamic and typed code, together. In this article, I want to show how we can build a dynamic reactive enum with TS and RxJS","series":"","tags":["rxjs","typescript"]},{"live":true,"readingTime":"8 min read","title":"Caching RxJS streams into Web Storage","date":"2021-11-10T23:00:00.000Z","slug":"caching-rxjs-streams-into-web-storage","coverImage":"/assets/caching-rxjs-streams.webp","collection":{"name":"RxJs","primaryColor":"#d81b60","primaryColorLight":"#d81b6085","contrastColor":"#fff","logo":"/assets/images/collections/rxjs.webp"},"excerpt":"In this article I will introduce you to a simple utility that allows you to cache RxJS streams in memory or the browser's storage","series":"","tags":["rxjs"]},{"live":true,"readingTime":"6 min read","title":"5 common mistakes with RxJS","date":"2020-08-03T00:00:00.322Z","slug":"five-common-mistakes-with-rxjs","coverImage":"https://miro.medium.com/max/1400/1*SZ7Ubdlu8CbNjvI8-LezVw.jpeg","collection":{"name":"RxJs","primaryColor":"#d81b60","primaryColorLight":"#d81b6085","contrastColor":"#fff","logo":"/assets/images/collections/rxjs.webp"},"excerpt":"A list of common mistakes while using RxJS, and explanations on what to do instead","tags":["rxjs"]},{"live":true,"readingTime":"7 min read","title":"RxJS Subjects in Depth","date":"2019-10-15T00:00:00.000Z","slug":"rxjs-subjects-in-depth","coverImage":"https://cdn-images-1.medium.com/max/14720/0*15QkEYFTChBSrv-J","collection":{"name":"RxJs","primaryColor":"#d81b60","primaryColorLight":"#d81b6085","contrastColor":"#fff","logo":"/assets/images/collections/rxjs.webp"},"excerpt":"Learn how RxJS Subjects are used in real-world applications","tags":["rxjs"]},{"live":true,"readingTime":"5 min read","title":"A simple Countdown with RxJS","date":"2019-06-05T00:00:00.322Z","slug":"a-simple-countdown-with-rx-js","coverImage":"/assets/images/posts/rxjs-countdown.gif","collection":{"name":"RxJs","primaryColor":"#d81b60","primaryColorLight":"#d81b6085","contrastColor":"#fff","logo":"/assets/images/collections/rxjs.webp"},"excerpt":"In this tutorial, we’re going to build a very simple timer application with only a few lines of code using RxJS","tags":["rxjs"]}],"type":1},"__N_SSG":true}