{"pageProps":{"post":{"live":true,"readingTime":"3 min read","title":"Where to put your Angular models?","date":"2020-08-03T00:00:00.322Z","slug":"angular-where-to-put-models","ogImage":{"url":"/assets/images/posts/where-put-angular-models.png"},"coverImage":"/assets/images/posts/where-put-angular-models.webp","collection":"angular","excerpt":"Organizing entities and models in your Angular app may be hard. This article explains where to put your entities and what mistakes to watch out for","content":"\nBefore we go into detail - it's worth understanding what we mean by models:\n\n- entity classes?\n- enums?\n- interfaces?\n\nIt could be all of them - depending on who you ask.\n\nI personally like to differentiate between interfaces and models as two distinct things:\n\n- `interfaces` are used to define the shape of my Typescript entities\n- `models` are used as to define the actual value of my interfaces\n\n### How to organize your models in your Angular Project Structure\n\nEvery module may have a set of entities (models, enums, etc.) that are either private or public to the module itself.\n\nLet's assume we have a module called `UsersModule`. We want to define, for every entity, a sensible folder structure:\n\n```\n- users\n    - components\n    - services\n    - enums\n        - roles.enum.ts\n    - interfaces\n        - user.interface.ts\n    - models\n```\n\nAs you may have noticed, enums, interfaces and models all have their own folder, and it's important not to mix them to keep them well-organized.\n\n## Entities Visibility\n\nThere are a few rules that I tend to follow to make sure my project is well-organized.\n\n### Use a shared library for entities used outside of your modules\n\nIt's important to notice that a module should only contain the entities that are not shared with other modules, and hence that are private to that module.\n\nBut - Why?\n\nImagine we have a mono-repo with other applications or libraries written in different technologies (ex. Express, Stencil, React, etc.): you may not want to import your types from a different technology.\n\n#### ðŸ’¡ Solution\nCreate a separate library (for example, called `@enterprise/interfaces`) that exposes your global entities. This is particularly recommended if you're using `Nx` to structure your project.\n\nOtherwise, consider creating a typescript repository to expose your global entities to different repositories.\n\nAdmittedly, this is not great - but if you have a large team of teams using the same interfaces, it could be really important to keep them in sync.\n\n### Never export an interface from a Service\n\nThis is a pattern that I quite dislike - and I see used very often.\n\nDefining an interface within a Service (or a Component) is generally fine - although not something I normally do. It's all good - as long as it is not exported.\n\nWhy is that?\n\n- A component should not import a service simply to get an Interface\n- A component may simply use Typescript inference instead of using that Interface\n- If the interface is reused and is used in a way that inference could not work, then it should defined in its own file\n\nHopefully this answered your questions - but if not, please do send me an [email](mailto:giancarlo@frontend.consulting) and I'd love to expand on the subject.\n\n_Thank you for reading, I hope you enjoyed this article. If you did, consider follow me on [Twitter](https://twitter.com/gc_psk) or sign up to the Newsletter using the form below!_\n"},"content":{"compiledSource":"var d=Object.defineProperty,m=Object.defineProperties;var h=Object.getOwnPropertyDescriptors;var a=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var l=(e,t,n)=>t in e?d(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,o=(e,t)=>{for(var n in t||(t={}))r.call(t,n)&&l(e,n,t[n]);if(a)for(var n of a(t))s.call(t,n)&&l(e,n,t[n]);return e},p=(e,t)=>m(e,h(t));var u=(e,t)=>{var n={};for(var i in e)r.call(e,i)&&t.indexOf(i)<0&&(n[i]=e[i]);if(e!=null&&a)for(var i of a(e))t.indexOf(i)<0&&s.call(e,i)&&(n[i]=e[i]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var i=n,{components:e}=i,t=u(i,[\"components\"]);return mdx(MDXLayout,p(o(o({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Before we go into detail - it's worth understanding what we mean by models:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"entity classes?\"),mdx(\"li\",{parentName:\"ul\"},\"enums?\"),mdx(\"li\",{parentName:\"ul\"},\"interfaces?\")),mdx(\"p\",null,\"It could be all of them - depending on who you ask.\"),mdx(\"p\",null,\"I personally like to differentiate between interfaces and models as two distinct things:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"interfaces\"),\" are used to define the shape of my Typescript entities\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"models\"),\" are used as to define the actual value of my interfaces\")),mdx(\"h3\",null,\"How to organize your models in your Angular Project Structure\"),mdx(\"p\",null,\"Every module may have a set of entities (models, enums, etc.) that are either private or public to the module itself.\"),mdx(\"p\",null,\"Let's assume we have a module called \",mdx(\"inlineCode\",{parentName:\"p\"},\"UsersModule\"),\". We want to define, for every entity, a sensible folder structure:\"),mdx(\"div\",o({},{className:\"remark-highlight\"}),mdx(\"pre\",o({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",o({parentName:\"pre\"},{className:\"language-unknown\"}),`- users\n    - components\n    - services\n    - enums\n        - roles.enum.ts\n    - interfaces\n        - user.interface.ts\n    - models`))),mdx(\"p\",null,\"As you may have noticed, enums, interfaces and models all have their own folder, and it's important not to mix them to keep them well-organized.\"),mdx(\"h2\",null,\"Entities Visibility\"),mdx(\"p\",null,\"There are a few rules that I tend to follow to make sure my project is well-organized.\"),mdx(\"h3\",null,\"Use a shared library for entities used outside of your modules\"),mdx(\"p\",null,\"It's important to notice that a module should only contain the entities that are not shared with other modules, and hence that are private to that module.\"),mdx(\"p\",null,\"But - Why?\"),mdx(\"p\",null,\"Imagine we have a mono-repo with other applications or libraries written in different technologies (ex. Express, Stencil, React, etc.): you may not want to import your types from a different technology.\"),mdx(\"h4\",null,\"\\u{1F4A1} Solution\"),mdx(\"p\",null,\"Create a separate library (for example, called \",mdx(\"inlineCode\",{parentName:\"p\"},\"@enterprise/interfaces\"),\") that exposes your global entities. This is particularly recommended if you're using \",mdx(\"inlineCode\",{parentName:\"p\"},\"Nx\"),\" to structure your project.\"),mdx(\"p\",null,\"Otherwise, consider creating a typescript repository to expose your global entities to different repositories.\"),mdx(\"p\",null,\"Admittedly, this is not great - but if you have a large team of teams using the same interfaces, it could be really important to keep them in sync.\"),mdx(\"h3\",null,\"Never export an interface from a Service\"),mdx(\"p\",null,\"This is a pattern that I quite dislike - and I see used very often.\"),mdx(\"p\",null,\"Defining an interface within a Service (or a Component) is generally fine - although not something I normally do. It's all good - as long as it is not exported.\"),mdx(\"p\",null,\"Why is that?\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"A component should not import a service simply to get an Interface\"),mdx(\"li\",{parentName:\"ul\"},\"A component may simply use Typescript inference instead of using that Interface\"),mdx(\"li\",{parentName:\"ul\"},\"If the interface is reused and is used in a way that inference could not work, then it should defined in its own file\")),mdx(\"p\",null,\"Hopefully this answered your questions - but if not, please do send me an \",mdx(\"a\",o({parentName:\"p\"},{href:\"mailto:giancarlo@frontend.consulting\"}),\"email\"),\" and I'd love to expand on the subject.\"),mdx(\"p\",null,mdx(\"em\",{parentName:\"p\"},\"Thank you for reading, I hope you enjoyed this article. If you did, consider follow me on \",mdx(\"a\",o({parentName:\"em\"},{href:\"https://twitter.com/gc_psk\"}),\"Twitter\"),\" or sign up to the Newsletter using the form below!\")))}MDXContent.isMDXComponent=!0;\n","scope":{}},"series":[],"morePosts":[],"moreArticles":[{"live":true,"readingTime":"2 min read","title":"Benchmarking Angular 12 with Webpack 5","date":"2021-05-14T00:00:00.322Z","slug":"webpack-5-angular12","coverImage":"/assets/images/posts/benchmarking-webpack-5.webp","collection":"angular","excerpt":"Angular 12 has been released and with it the much awaited Webpack 5 upgrade. In this post I benchmarked the bundle-size and compilation speed against the previous version","tags":["angular"]},{"live":true,"readingTime":"5 min read","title":"Principles for creating libraries with Nx and Angular","date":"2021-02-07T00:00:00.322Z","slug":"how-to-organize-nx-modules-with-angular","coverImage":"/assets/images/posts/organize-nx-modules-ngrx.webp","collection":"angular","excerpt":"Working with Nx may be confusing. This article explains how I create Nx libraries and the principles behind my motivations","tags":["nx","angular"]},{"live":true,"readingTime":"5 min read","title":"Using the Intersection Observer API with Angular","date":"2020-08-01T00:00:00.322Z","slug":"intersection-observer-with-angular","coverImage":"/assets/images/posts/intersection-observer.webp","collection":"angular","excerpt":"This article shows how to build a directive with Angular that uses the Intersection Observer API to check when an element becomes visible on the page","tags":["angular","performance"]},{"live":true,"readingTime":"3 min read","title":"Setters vs ngOnChanges: which one is better?","date":"2020-07-30T00:00:00.322Z","slug":"setters-vs-ng-on-changes","coverImage":"/assets/images/posts/setters-vs-on-changes.webp","collection":"angular","excerpt":"Listening to Input changes can be done in different ways. But which one should you use?","tags":["angular"]},{"live":true,"readingTime":"3 min read","title":"Async Rendering with a single Rx Operator","date":"2020-07-11T00:00:00.322Z","slug":"async-rendering-with-a-single-rx-operator","coverImage":"/assets/images/posts/async-rendering.webp","collection":"angular","excerpt":"Increase your app rendering performance with this simple Rx operator","tags":["angular","rxjs"]},{"live":true,"readingTime":"9 min read","title":"Building Scalable Multi-Platform Projects with Angular andÂ Nx","date":"2019-08-25T00:00:00.322Z","slug":"building-scalable-multi-platform-projects-with-angular-and-nx","coverImage":"/assets/images/posts/scalable-multiplatform-monorepo.jpeg","collection":"angular","excerpt":"Building a scalable multi-platform monorepo application with Angular and Nx","tags":["nx","angular","ionic"]}],"type":1},"__N_SSG":true}