{"pageProps":{"post":{"live":true,"readingTime":"3 min read","title":"Using Firestore's SDK in Next.js's SSR","date":"2021-11-27T16:30:30.000Z","slug":"using-firestore-sdk-in-next.js-ssr","collection":{"name":"Next","primaryColor":"#111","primaryColorLight":"#111111a6","contrastColor":"#ffffff","logo":"/assets/images/collections/next.webp","slug":"next"},"content":"As I'm venturing into using Next.js to build a Saas boilerplate (coming soon), I'm beginning to understand that while SSR is fantastic, it has a ton of gotchas you need to know before thinking of adopting it.\n\nAfter spending the better part of my day trying to server-render a component that uses the Firebase SDK, I thought this write-up could help other people.\n\nSo, what's the issue?\n\nFirebase has always had a messy relationship with Javascript SDKs. There are many, and they're confusing. The newest v9 version does help a bit, but it made my issue worse.\n\nMy code uses `reactfire` to render a FirebaseAppProvider component which initializes a new Firebase App and creates a Context so that you can use `useFirebaseApp` to use the app throughout the application.\n\nOne of my components is making a Firestore query, which gets rendered on the server for obvious reasons. However, even if the query doesn't return a result, being asynchronous, it will still call the SDK.\n\nIf you're using the Reactfire example, you may be initializing your component in this way:\n\n```tsx\n<FirebaseAppProvider firebaseConfig={config}>  \n  {children}  \n</FirebaseAppProvider>\n```\n\nBut then I was met with the following error:\n\n    FirebaseError: Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore\n\nAt first, I thought the `Firestore` instance using `useFirestore` became `null` before or after a re-render. That was wrong.\n\nThe instance was fine; the issue was deep down the Firestore's SDK.\n\nWhat happens? Firestore checks that the Firestore instance was created using the same SDK, even if it is perfectly working. If it's not, then it will throw this somewhat cryptic error.\n\nIt can happen when a Firebase/Firestore instance gets created by another version of the Firebase SDK. Instead of letting `reactfire` create the Firebase instance for me, and I decided to pass it down manually.\n\nThe code above becomes:\n\n```tsx\nconst app = initializeApp(config);\n\nreturn (\n \t<FirebaseAppProvider firebaseApp={app}>\n    \t{children}\n\t</FirebaseAppProvider>\n);\n```\n\nThe error changes, still no luck.\n\n    FirebaseError: Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?\n\nBut I feel like I'm getting closer, as the issue now comes from the actual query call, a few lines down.\n\nMy feeling at this point is that Firebase is initializing Firestore using the ESM version of the SDK, yet executing the query using the CommonJS version.\n\nThis is where the stack trace points to:\n\n    file:///Users/giancarlo/Code/project/node_modules/@firebase/firestore/dist/index.node.cjs.js (18550:19)\n\nFirestore uses a function `cast` to check that the instance is the same as the instance from the same library. \n\nI have not confirmed this yet with the team (I may open a bug in `rxfire`), but it seems like `rxfire` is using the wrong version to perform queries. The library `reactfire` uses `rxfire` under the hood; if you're not using it, there is a good chance your code would have worked fine.\n\n## The solution\n\nAt this point, I try to play with Next.js's options. If use `type: \"module\"` in my `package.json`, I could force `rxfire` to use the ESM version? Doing so opened a can of worms, so I ditched the possibility for the time being.\n\nThen I tried to disable one of Next.js 12's experimental features that got turned on by default in the latest release.\n\nI changed the `next.config.js` configuration file and set the `esmExternals` property to `false`.\n\n```tsx\nexperimental: {\n  esmExternals: false\n}\n```\n\nI could not believe my eyes: after several hours of debugging and head-scratching, I got the Firestore SDK to work with SSR.\n\nThe issue is that without `Suspense` my queries aren't working - so they get only fetched on the client, but for now, it's good enough.\n\nI'll try Suspense's beta soon: enough head-scratching for today.","tags":["next","firebase","react"],"ogImage":{"url":"/assets/images/posts/using-firestore-sdk-in-next.js-ssr.webp"}},"content":{"compiledSource":"var l=Object.defineProperty,d=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var p=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var r=(a,n,t)=>n in a?l(a,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[n]=t,e=(a,n)=>{for(var t in n||(n={}))o.call(n,t)&&r(a,t,n[t]);if(p)for(var t of p(n))i.call(n,t)&&r(a,t,n[t]);return a},c=(a,n)=>d(a,u(n));var m=(a,n)=>{var t={};for(var s in a)o.call(a,s)&&n.indexOf(s)<0&&(t[s]=a[s]);if(a!=null&&p)for(var s of p(a))n.indexOf(s)<0&&i.call(a,s)&&(t[s]=a[s]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var s=t,{components:a}=s,n=m(s,[\"components\"]);return mdx(MDXLayout,c(e(e({},layoutProps),n),{components:a,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"As I'm venturing into using Next.js to build a Saas boilerplate (coming soon), I'm beginning to understand that while SSR is fantastic, it has a ton of gotchas you need to know before thinking of adopting it.\"),mdx(\"p\",null,\"After spending the better part of my day trying to server-render a component that uses the Firebase SDK, I thought this write-up could help other people.\"),mdx(\"p\",null,\"So, what's the issue?\"),mdx(\"p\",null,\"Firebase has always had a messy relationship with Javascript SDKs. There are many, and they're confusing. The newest v9 version does help a bit, but it made my issue worse.\"),mdx(\"p\",null,\"My code uses \",mdx(\"inlineCode\",{parentName:\"p\"},\"reactfire\"),\" to render a FirebaseAppProvider component which initializes a new Firebase App and creates a Context so that you can use \",mdx(\"inlineCode\",{parentName:\"p\"},\"useFirebaseApp\"),\" to use the app throughout the application.\"),mdx(\"p\",null,\"One of my components is making a Firestore query, which gets rendered on the server for obvious reasons. However, even if the query doesn't return a result, being asynchronous, it will still call the SDK.\"),mdx(\"p\",null,\"If you're using the Reactfire example, you may be initializing your component in this way:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-tsx\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tsx\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token tag\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token tag\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\"<\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token class-name\"}),\"FirebaseAppProvider\")),\" \",mdx(\"span\",e({parentName:\"span\"},{className:\"token attr-name\"}),\"firebaseConfig\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token script language-javascript\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token script-punctuation punctuation\"}),\"=\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\"{\"),\"config\",mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\"}\")),mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\">\")),mdx(\"span\",e({parentName:\"code\"},{className:\"token plain-text\"}),\"  \"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token plain-text\"}),\"  \"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),\"children\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token plain-text\"}),\"  \"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token plain-text\"})),mdx(\"span\",e({parentName:\"code\"},{className:\"token tag\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token tag\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\"</\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token class-name\"}),\"FirebaseAppProvider\")),mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\">\")),`\n`))),mdx(\"p\",null,\"But then I was met with the following error:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),\"FirebaseError: Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore\"))),mdx(\"p\",null,\"At first, I thought the \",mdx(\"inlineCode\",{parentName:\"p\"},\"Firestore\"),\" instance using \",mdx(\"inlineCode\",{parentName:\"p\"},\"useFirestore\"),\" became \",mdx(\"inlineCode\",{parentName:\"p\"},\"null\"),\" before or after a re-render. That was wrong.\"),mdx(\"p\",null,\"The instance was fine; the issue was deep down the Firestore's SDK.\"),mdx(\"p\",null,\"What happens? Firestore checks that the Firestore instance was created using the same SDK, even if it is perfectly working. If it's not, then it will throw this somewhat cryptic error.\"),mdx(\"p\",null,\"It can happen when a Firebase/Firestore instance gets created by another version of the Firebase SDK. Instead of letting \",mdx(\"inlineCode\",{parentName:\"p\"},\"reactfire\"),\" create the Firebase instance for me, and I decided to pass it down manually.\"),mdx(\"p\",null,\"The code above becomes:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-tsx\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tsx\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"const\"),\" app \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"initializeApp\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"config\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"return\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),`\n \t`,mdx(\"span\",e({parentName:\"code\"},{className:\"token tag\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token tag\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\"<\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token class-name\"}),\"FirebaseAppProvider\")),\" \",mdx(\"span\",e({parentName:\"span\"},{className:\"token attr-name\"}),\"firebaseApp\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token script language-javascript\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token script-punctuation punctuation\"}),\"=\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\"{\"),\"app\",mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\"}\")),mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\">\")),mdx(\"span\",e({parentName:\"code\"},{className:\"token plain-text\"})),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token plain-text\"}),\"    \t\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),\"children\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token plain-text\"})),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token plain-text\"}),\"\t\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token tag\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token tag\"}),mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\"</\"),mdx(\"span\",e({parentName:\"span\"},{className:\"token class-name\"}),\"FirebaseAppProvider\")),mdx(\"span\",e({parentName:\"span\"},{className:\"token punctuation\"}),\">\")),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),`\n`))),mdx(\"p\",null,\"The error changes, still no luck.\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),\"FirebaseError: Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?\"))),mdx(\"p\",null,\"But I feel like I'm getting closer, as the issue now comes from the actual query call, a few lines down.\"),mdx(\"p\",null,\"My feeling at this point is that Firebase is initializing Firestore using the ESM version of the SDK, yet executing the query using the CommonJS version.\"),mdx(\"p\",null,\"This is where the stack trace points to:\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-unknown\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-unknown\"}),\"file:///Users/giancarlo/Code/project/node_modules/@firebase/firestore/dist/index.node.cjs.js (18550:19)\"))),mdx(\"p\",null,\"Firestore uses a function \",mdx(\"inlineCode\",{parentName:\"p\"},\"cast\"),\" to check that the instance is the same as the instance from the same library. \"),mdx(\"p\",null,\"I have not confirmed this yet with the team (I may open a bug in \",mdx(\"inlineCode\",{parentName:\"p\"},\"rxfire\"),\"), but it seems like \",mdx(\"inlineCode\",{parentName:\"p\"},\"rxfire\"),\" is using the wrong version to perform queries. The library \",mdx(\"inlineCode\",{parentName:\"p\"},\"reactfire\"),\" uses \",mdx(\"inlineCode\",{parentName:\"p\"},\"rxfire\"),\" under the hood; if you're not using it, there is a good chance your code would have worked fine.\"),mdx(\"h2\",null,\"The solution\"),mdx(\"p\",null,\"At this point, I try to play with Next.js's options. If use \",mdx(\"inlineCode\",{parentName:\"p\"},'type: \"module\"'),\" in my \",mdx(\"inlineCode\",{parentName:\"p\"},\"package.json\"),\", I could force \",mdx(\"inlineCode\",{parentName:\"p\"},\"rxfire\"),\" to use the ESM version? Doing so opened a can of worms, so I ditched the possibility for the time being.\"),mdx(\"p\",null,\"Then I tried to disable one of Next.js 12's experimental features that got turned on by default in the latest release.\"),mdx(\"p\",null,\"I changed the \",mdx(\"inlineCode\",{parentName:\"p\"},\"next.config.js\"),\" configuration file and set the \",mdx(\"inlineCode\",{parentName:\"p\"},\"esmExternals\"),\" property to \",mdx(\"inlineCode\",{parentName:\"p\"},\"false\"),\".\"),mdx(\"div\",e({},{className:\"remark-highlight\"}),mdx(\"pre\",e({parentName:\"div\"},{className:\"language-tsx\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tsx\"}),\"experimental\",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n  esmExternals`,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\":\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token boolean\"}),\"false\"),`\n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`))),mdx(\"p\",null,\"I could not believe my eyes: after several hours of debugging and head-scratching, I got the Firestore SDK to work with SSR.\"),mdx(\"p\",null,\"The issue is that without \",mdx(\"inlineCode\",{parentName:\"p\"},\"Suspense\"),\" my queries aren't working - so they get only fetched on the client, but for now, it's good enough.\"),mdx(\"p\",null,\"I'll try Suspense's beta soon: enough head-scratching for today.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"series":[],"morePosts":[],"moreArticles":[{"live":true,"readingTime":"3 min read","title":"Announcing MakerKit - A SaaS starter for Next.js and Firebase","date":"2021-12-17T23:00:00.000Z","slug":"announcing-makerkit-boilerplate-for-building-saas-with-next.js-firebase","coverImage":"/assets/images/posts/makerkit-post.webp","collection":{"name":"Next","primaryColor":"#111","primaryColorLight":"#111111a6","contrastColor":"#ffffff","logo":"/assets/images/collections/next.webp","slug":"next"},"excerpt":"MakerKit is a SaaS starter for Next.js, Firebase, and Tailwind CSS. It comes with authentication, organizations, payments with Stripe, a blog and documentation generators, and much more.","tags":["react","typescript","next","firebase"]},{"live":true,"readingTime":"7 min read","title":"A Scalable Project Structure for Next.js","date":"2021-12-10T00:00:00.000Z","slug":"a-scalable-nextjs-project-structure","collection":{"name":"Next","primaryColor":"#111","primaryColorLight":"#111111a6","contrastColor":"#ffffff","logo":"/assets/images/collections/next.webp","slug":"next"},"excerpt":"Next.js and React are not opinionated. Much is left to us to figure out - and without rules, our code can get wild pretty quickly. In this post I explain the rationale behind the way I structure my Next.js projects for small and medium-sized apps","tags":["next","react"]},{"live":true,"readingTime":"8 min read","title":"Generating automatic banners for your Blog","date":"2021-12-03T00:00:00.322Z","slug":"automatic-banners-for-your-blog","collection":{"name":"Next","primaryColor":"#111","primaryColorLight":"#111111a6","contrastColor":"#ffffff","logo":"/assets/images/collections/next.webp","slug":"next"},"excerpt":"Say no to custom banners. This post will teach you how to generate automatic banners for your articles using Next.js, SVG and Sharp","tags":["next","react"]}],"type":0},"__N_SSG":true}